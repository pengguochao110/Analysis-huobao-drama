# 05-AI服务集成

本文档详细介绍火宝短剧项目如何集成和管理 AI 服务提供商。

---

## 1. AI服务架构回顾

### 1.1 Provider接口定义

项目使用 **Provider 模式** 支持多 AI 提供商动态切换：

```go
// pkg/ai/client.go

package ai

// AIClient 定义文本生成客户端接口
type AIClient interface {
    // GenerateText 生成文本
    // prompt: 用户提示词
    // systemPrompt: 系统提示词（角色设定）
    // options: 可选参数（温度、最大token等）
    GenerateText(prompt string, systemPrompt string, options ...func(*ChatCompletionRequest)) (string, error)
    
    // GenerateImage 生成图片
    // prompt: 图片描述
    // size: 图片尺寸（如 "1024x1024"）
    // n: 生成数量
    GenerateImage(prompt string, size string, n int) ([]string, error)
    
    // TestConnection 测试连接
    TestConnection() error
}

// ChatCompletionRequest 聊天完成请求
type ChatCompletionRequest struct {
    Model       string  `json:"model"`
    Messages    []Message `json:"messages"`
    Temperature float64 `json:"temperature,omitempty"`
    MaxTokens   int     `json:"max_tokens,omitempty"`
    TopP        float64 `json:"top_p,omitempty"`
}

type Message struct {
    Role    string `json:"role"`
    Content string `json:"content"`
}

// ClientOption 客户端选项函数
type ClientOption func(*BaseClient)

// BaseClient 基础客户端配置
type BaseClient struct {
    BaseURL    string
    APIKey     string
    Model      string
    Timeout    time.Duration
    MaxRetries int
}
```

### 1.2 配置管理系统

AI 配置存储在数据库中，支持前端动态配置：

```go
// domain/models/ai_config.go

// AIServiceConfig AI 服务配置
type AIServiceConfig struct {
    ID          uint      `gorm:"primaryKey" json:"id"`
    Name        string    `json:"name"`        // 配置名称（如 "OpenAI GPT-4"）
    Provider    string    `json:"provider"`    // 提供商类型：openai, gemini, doubao
    Model       string    `json:"model"`       // 模型名称
    APIKey      string    `json:"api_key"`     // API密钥（加密存储）
    BaseURL     string    `json:"base_url"`    // 基础URL（支持自定义）
    Temperature float64   `json:"temperature"` // 温度参数
    MaxTokens   int       `json:"max_tokens"`  // 最大token数
    Timeout     int       `json:"timeout"`     // 超时时间（秒）
    IsActive    bool      `json:"is_active"`   // 是否启用
    IsDefault   bool      `json:"is_default"`  // 是否为默认配置
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

// ProviderType 提供商类型常量
const (
    ProviderOpenAI      = "openai"
    ProviderGemini      = "gemini"
    ProviderDoubao      = "doubao"
    ProviderVolces      = "volces"      // 火山引擎
    ProviderMiniMax     = "minimax"
    ProviderChatFire    = "chatfire"
)

// CapabilityType 能力类型
const (
    CapabilityText  = "text"   // 文本生成
    CapabilityImage = "image"  // 图片生成
    CapabilityVideo = "video"  // 视频生成
)
```

### 1.3 客户端工厂

通过工厂模式根据配置创建对应客户端：

```go
// application/services/ai_service.go

func (s *AIService) GetClient(config *models.AIServiceConfig) (ai.AIClient, error) {
    switch config.Provider {
    case models.ProviderOpenAI:
        return ai.NewOpenAIClient(config.APIKey, config.Model, config.BaseURL), nil
        
    case models.ProviderGemini:
        return ai.NewGeminiClient(config.APIKey, config.Model), nil
        
    case models.ProviderDoubao:
        return ai.NewDoubaoClient(config.APIKey, config.Model), nil
        
    default:
        return nil, fmt.Errorf("不支持的提供商: %s", config.Provider)
    }
}

// GetProviderForCapability 根据能力类型获取提供商
func (s *AIService) GetProviderForCapability(capability string) (*models.AIServiceConfig, error) {
    var config models.AIServiceConfig
    
    // 查找该能力的默认配置
    err := s.db.Where("provider_type = ? AND is_active = ? AND is_default = ?", 
        capability, true, true).First(&config).Error
    
    if err != nil {
        return nil, fmt.Errorf("未找到 %s 的默认配置", capability)
    }
    
    return &config, nil
}
```

---

## 2. 接入新AI提供商示例：以接入Midjourney为例

### Step 1：定义MidjourneyProvider结构体

创建文件：`pkg/ai/midjourney_client.go`

```go
package ai

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

// MidjourneyClient Midjourney API 客户端
type MidjourneyClient struct {
    BaseURL    string
    APIKey     string
    Model      string  // 如 "midjourney-v6"
    Timeout    time.Duration
    HTTPClient *http.Client
}

// NewMidjourneyClient 创建 Midjourney 客户端
func NewMidjourneyClient(apiKey, model, baseURL string) *MidjourneyClient {
    if baseURL == "" {
        baseURL = "https://api.midjourney.com/v1" // 示例地址
    }
    
    return &MidjourneyClient{
        BaseURL: baseURL,
        APIKey:  apiKey,
        Model:   model,
        Timeout: 120 * time.Second, // 图片生成耗时较长
        HTTPClient: &http.Client{
            Timeout: 120 * time.Second,
        },
    }
}

// MidjourneyRequest Midjourney 请求结构
type MidjourneyRequest struct {
    Prompt      string   `json:"prompt"`
    AspectRatio string   `json:"aspect_ratio,omitempty"` // 如 "16:9"
    Style       string   `json:"style,omitempty"`        // 如 "raw", "cinematic"
    Chaos       int      `json:"chaos,omitempty"`        // 0-100
    Weird       int      `json:"weird,omitempty"`        // 0-3000
}

// MidjourneyResponse Midjourney 响应结构
type MidjourneyResponse struct {
    JobID     string   `json:"job_id"`
    Status    string   `json:"status"`
    ImageURLs []string `json:"image_urls,omitempty"`
    Error     string   `json:"error,omitempty"`
}
```

### Step 2：实现AIProvider接口

```go
// GenerateText Midjourney 不支持文本生成，返回错误
func (c *MidjourneyClient) GenerateText(prompt string, systemPrompt string, options ...func(*ChatCompletionRequest)) (string, error) {
    return "", fmt.Errorf("Midjourney 不支持文本生成")
}

// GenerateImage 生成图片
func (c *MidjourneyClient) GenerateImage(prompt string, size string, n int) ([]string, error) {
    // 转换尺寸到 Midjourney 的 aspect ratio
    aspectRatio := c.convertSizeToAspectRatio(size)
    
    reqBody := MidjourneyRequest{
        Prompt:      prompt,
        AspectRatio: aspectRatio,
        Style:       "raw",
    }
    
    jsonBody, err := json.Marshal(reqBody)
    if err != nil {
        return nil, fmt.Errorf("序列化请求失败: %w", err)
    }
    
    // 创建请求
    req, err := http.NewRequest("POST", c.BaseURL+"/imagine", bytes.NewBuffer(jsonBody))
    if err != nil {
        return nil, fmt.Errorf("创建请求失败: %w", err)
    }
    
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+c.APIKey)
    
    // 发送请求
    resp, err := c.HTTPClient.Do(req)
    if err != nil {
        return nil, fmt.Errorf("发送请求失败: %w", err)
    }
    defer resp.Body.Close()
    
    // 解析响应
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("读取响应失败: %w", err)
    }
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("API 错误 (状态码 %d): %s", resp.StatusCode, string(body))
    }
    
    var mjResp MidjourneyResponse
    if err := json.Unmarshal(body, &mjResp); err != nil {
        return nil, fmt.Errorf("解析响应失败: %w", err)
    }
    
    if mjResp.Status == "failed" {
        return nil, fmt.Errorf("生成失败: %s", mjResp.Error)
    }
    
    // Midjourney 是异步的，需要轮询任务状态
    if mjResp.Status == "pending" || mjResp.Status == "processing" {
        imageURLs, err := c.pollForResult(mjResp.JobID)
        if err != nil {
            return nil, err
        }
        return imageURLs, nil
    }
    
    return mjResp.ImageURLs, nil
}

// TestConnection 测试连接
func (c *MidjourneyClient) TestConnection() error {
    req, err := http.NewRequest("GET", c.BaseURL+"/health", nil)
    if err != nil {
        return err
    }
    
    req.Header.Set("Authorization", "Bearer "+c.APIKey)
    
    resp, err := c.HTTPClient.Do(req)
    if err != nil {
        return fmt.Errorf("连接测试失败: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("连接测试失败，状态码: %d", resp.StatusCode)
    }
    
    return nil
}

// pollForResult 轮询任务结果
func (c *MidjourneyClient) pollForResult(jobID string) ([]string, error) {
    maxRetries := 30
    retryInterval := 10 * time.Second
    
    for i := 0; i < maxRetries; i++ {
        time.Sleep(retryInterval)
        
        req, err := http.NewRequest("GET", fmt.Sprintf("%s/job/%s", c.BaseURL, jobID), nil)
        if err != nil {
            return nil, err
        }
        
        req.Header.Set("Authorization", "Bearer "+c.APIKey)
        
        resp, err := c.HTTPClient.Do(req)
        if err != nil {
            continue
        }
        
        body, _ := io.ReadAll(resp.Body)
        resp.Body.Close()
        
        var result MidjourneyResponse
        if err := json.Unmarshal(body, &result); err != nil {
            continue
        }
        
        switch result.Status {
        case "completed":
            return result.ImageURLs, nil
        case "failed":
            return nil, fmt.Errorf("任务失败: %s", result.Error)
        case "pending", "processing":
            continue
        }
    }
    
    return nil, fmt.Errorf("轮询超时，任务未完成")
}

// convertSizeToAspectRatio 转换尺寸到比例
func (c *MidjourneyClient) convertSizeToAspectRatio(size string) string {
    switch size {
    case "1024x1024":
        return "1:1"
    case "1024x1792":
        return "9:16"
    case "1792x1024":
        return "16:9"
    default:
        return "1:1"
    }
}
```

### Step 3：添加配置参数

修改配置模型：`domain/models/ai_config.go`

```go
const (
    // 现有提供商...
    ProviderMidjourney = "midjourney" // 新增
)

// MidjourneyParams Midjourney 特定参数
type MidjourneyParams struct {
    AspectRatio string `json:"aspect_ratio"` // 图片比例
    Style       string `json:"style"`        // 风格
    Chaos       int    `json:"chaos"`        // 多样性
    Quality     string `json:"quality"`      // 质量
}
```

### Step 4：UI界面配置支持

前端添加 Midjourney 选项：

```vue
<!-- web/src/components/AIConfigForm.vue -->

<script setup lang="ts">
const providerOptions = [
  { label: 'OpenAI', value: 'openai', capabilities: ['text', 'image'] },
  { label: 'Gemini', value: 'gemini', capabilities: ['text', 'image'] },
  { label: '豆包', value: 'doubao', capabilities: ['text', 'video'] },
  { label: 'Midjourney', value: 'midjourney', capabilities: ['image'] }, // 新增
]

const capabilityLabels = {
  text: '文本生成',
  image: '图片生成',
  video: '视频生成',
}
</script>

<template>
  <el-form>
    <el-form-item label="AI 提供商">
      <el-select v-model="form.provider">
        <el-option
          v-for="provider in providerOptions"
          :key="provider.value"
          :label="provider.label"
          :value="provider.value"
        >
          <span>{{ provider.label }}</span>
          <el-tag
            v-for="cap in provider.capabilities"
            :key="cap"
            size="small"
            class="ml-2"
          >
            {{ capabilityLabels[cap] }}
          </el-tag>
        </el-option>
      </el-select>
    </el-form-item>
    
    <!-- Midjourney 特定参数 -->
    <template v-if="form.provider === 'midjourney'">
      <el-form-item label="图片比例">
        <el-select v-model="form.params.aspect_ratio">
          <el-option label="1:1 正方形" value="1:1" />
          <el-option label="16:9 横屏" value="16:9" />
          <el-option label="9:16 竖屏" value="9:16" />
          <el-option label="4:3 横屏" value="4:3" />
          <el-option label="3:4 竖屏" value="3:4" />
        </el-select>
      </el-form-item>
      
      <el-form-item label="风格">
        <el-select v-model="form.params.style">
          <el-option label="Raw (原始)" value="raw" />
          <el-option label="Cinematic (电影感)" value="cinematic" />
          <el-option label="Anime (动漫)" value="anime" />
        </el-select>
      </el-form-item>
    </template>
  </el-form>
</template>
```

### Step 5：测试验证

```go
// pkg/ai/midjourney_client_test.go

package ai

import (
    "testing"
    "time"
    
    "github.com/stretchr/testify/assert"
)

func TestMidjourneyClient_New(t *testing.T) {
    client := NewMidjourneyClient("test-key", "midjourney-v6", "")
    
    assert.NotNil(t, client)
    assert.Equal(t, "test-key", client.APIKey)
    assert.Equal(t, "midjourney-v6", client.Model)
    assert.Equal(t, 120*time.Second, client.Timeout)
}

func TestMidjourneyClient_ConvertSize(t *testing.T) {
    client := NewMidjourneyClient("", "", "")
    
    tests := []struct {
        size     string
        expected string
    }{
        {"1024x1024", "1:1"},
        {"1024x1792", "9:16"},
        {"1792x1024", "16:9"},
        {"unknown", "1:1"},
    }
    
    for _, test := range tests {
        result := client.convertSizeToAspectRatio(test.size)
        assert.Equal(t, test.expected, result)
    }
}

func TestMidjourneyClient_GenerateText_NotSupported(t *testing.T) {
    client := NewMidjourneyClient("test-key", "midjourney-v6", "")
    
    _, err := client.GenerateText("test", "")
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "不支持文本生成")
}

// 集成测试（需要真实 API Key）
func TestMidjourneyClient_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("跳过集成测试")
    }
    
    apiKey := os.Getenv("MIDJOURNEY_API_KEY")
    if apiKey == "" {
        t.Skip("未设置 MIDJOURNEY_API_KEY")
    }
    
    client := NewMidjourneyClient(apiKey, "midjourney-v6", "")
    
    // 测试连接
    err := client.TestConnection()
    assert.NoError(t, err)
    
    // 测试图片生成
    urls, err := client.GenerateImage("a beautiful sunset over the ocean", "1024x1024", 1)
    assert.NoError(t, err)
    assert.NotEmpty(t, urls)
}
```

---

## 3. 高级功能实现

### 3.1 超时控制

```go
// pkg/ai/openai_client.go

const (
    DefaultTextTimeout   = 30 * time.Second
    DefaultImageTimeout  = 120 * time.Second
    DefaultVideoTimeout  = 300 * time.Second
)

type OpenAIClient struct {
    apiKey     string
    model      string
    textTimeout   time.Duration
    imageTimeout  time.Duration
    videoTimeout  time.Duration
    httpClient    *http.Client
}

// NewOpenAIClientWithTimeouts 创建带自定义超时的客户端
func NewOpenAIClientWithTimeouts(apiKey, model string, textTimeout, imageTimeout, videoTimeout time.Duration) *OpenAIClient {
    return &OpenAIClient{
        apiKey:       apiKey,
        model:        model,
        textTimeout:  textTimeout,
        imageTimeout: imageTimeout,
        videoTimeout: videoTimeout,
        httpClient:   &http.Client{},
    }
}

// GenerateText 生成文本（30秒超时）
func (c *OpenAIClient) GenerateText(prompt string, systemPrompt string, options ...func(*ChatCompletionRequest)) (string, error) {
    ctx, cancel := context.WithTimeout(context.Background(), c.textTimeout)
    defer cancel()
    
    req := c.buildTextRequest(prompt, systemPrompt, options...)
    
    return c.executeWithContext(ctx, req)
}

// GenerateImage 生成图片（120秒超时）
func (c *OpenAIClient) GenerateImage(prompt string, size string, n int) ([]string, error) {
    ctx, cancel := context.WithTimeout(context.Background(), c.imageTimeout)
    defer cancel()
    
    req := c.buildImageRequest(prompt, size, n)
    
    return c.executeImageWithContext(ctx, req)
}
```

### 3.2 重试机制

```go
// pkg/ai/retry.go

package ai

import (
    "fmt"
    "time"
)

// RetryConfig 重试配置
type RetryConfig struct {
    MaxRetries  int
    BaseDelay   time.Duration
    MaxDelay    time.Duration
    Multiplier  float64
}

// DefaultRetryConfig 默认重试配置
var DefaultRetryConfig = RetryConfig{
    MaxRetries: 3,
    BaseDelay:  1 * time.Second,
    MaxDelay:   30 * time.Second,
    Multiplier: 2.0,
}

// ExponentialBackoff 指数退避
func ExponentialBackoff(config RetryConfig, attempt int) time.Duration {
    delay := config.BaseDelay
    
    // 计算指数延迟
    for i := 0; i < attempt; i++ {
        delay = time.Duration(float64(delay) * config.Multiplier)
    }
    
    // 添加随机抖动（±25%）
    jitter := time.Duration(float64(delay) * 0.25 * (2*rand.Float64() - 1))
    delay = delay + jitter
    
    // 限制最大延迟
    if delay > config.MaxDelay {
        delay = config.MaxDelay
    }
    
    return delay
}

// WithRetry 带重试的执行函数
func WithRetry[T any](config RetryConfig, operation func() (T, error)) (T, error) {
    var result T
    var err error
    
    for attempt := 0; attempt <= config.MaxRetries; attempt++ {
        result, err = operation()
        if err == nil {
            return result, nil
        }
        
        // 判断是否可重试
        if !isRetryableError(err) {
            return result, err
        }
        
        if attempt < config.MaxRetries {
            delay := ExponentialBackoff(config, attempt)
            time.Sleep(delay)
        }
    }
    
    return result, fmt.Errorf("重试 %d 次后仍失败: %w", config.MaxRetries, err)
}

// isRetryableError 判断错误是否可重试
func isRetryableError(err error) bool {
    if err == nil {
        return false
    }
    
    errStr := err.Error()
    
    // 可重试的错误类型
    retryablePatterns := []string{
        "connection refused",
        "timeout",
        "temporary",
        "rate limit",
        "too many requests",
        "503",
        "502",
        "504",
    }
    
    for _, pattern := range retryablePatterns {
        if contains(errStr, pattern) {
            return true
        }
    }
    
    return false
}
```

在客户端中使用重试：

```go
func (c *OpenAIClient) GenerateTextWithRetry(prompt string, systemPrompt string) (string, error) {
    return WithRetry(DefaultRetryConfig, func() (string, error) {
        return c.GenerateText(prompt, systemPrompt)
    })
}
```

### 3.3 降级策略

```go
// application/services/ai_service.go

// FallbackStrategy 降级策略
type FallbackStrategy struct {
    Primary   *models.AIServiceConfig
    Fallbacks []*models.AIServiceConfig
}

// GenerateWithFallback 带降级策略的生成
func (s *AIService) GenerateWithFallback(
    capability string, 
    prompt string, 
    options ...GenerateOption,
) (*GenerateResult, error) {
    
    // 获取提供商链（主 + 降级）
    chain, err := s.getProviderChain(capability)
    if err != nil {
        return nil, err
    }
    
    var lastErr error
    
    // 依次尝试每个提供商
    for i, config := range chain {
        client, err := s.GetClient(config)
        if err != nil {
            lastErr = err
            continue
        }
        
        result, err := s.generateWithClient(client, prompt, options...)
        if err == nil {
            // 记录使用的提供商
            result.Provider = config.Provider
            result.Model = config.Model
            
            // 如果是降级，记录日志
            if i > 0 {
                s.log.Warnw("使用降级提供商",
                    "primary", chain[0].Provider,
                    "fallback", config.Provider,
                    "capability", capability,
                )
            }
            
            return result, nil
        }
        
        lastErr = err
        s.log.Errorw("提供商调用失败，尝试下一个",
            "provider", config.Provider,
            "error", err,
        )
    }
    
    return nil, fmt.Errorf("所有提供商都失败: %w", lastErr)
}

// getProviderChain 获取提供商链
func (s *AIService) getProviderChain(capability string) ([]*models.AIServiceConfig, error) {
    var configs []*models.AIServiceConfig
    
    // 1. 获取默认提供商
    var defaultConfig models.AIServiceConfig
    if err := s.db.Where("provider_type = ? AND is_default = ? AND is_active = ?",
        capability, true, true).First(&defaultConfig).Error; err != nil {
        return nil, err
    }
    configs = append(configs, &defaultConfig)
    
    // 2. 获取备用提供商（按优先级排序）
    var fallbacks []models.AIServiceConfig
    s.db.Where("provider_type = ? AND is_active = ? AND id != ?",
        capability, true, defaultConfig.ID).
        Order("priority DESC").
        Find(&fallbacks)
    
    for i := range fallbacks {
        configs = append(configs, &fallbacks[i])
    }
    
    return configs, nil
}
```

### 3.4 成本统计

```go
// domain/models/ai_usage.go

// AIUsage AI 使用统计
type AIUsage struct {
    ID            uint      `gorm:"primaryKey" json:"id"`
    ConfigID      uint      `json:"config_id"`      // AI 配置 ID
    Provider      string    `json:"provider"`       // 提供商
    Model         string    `json:"model"`          // 模型
    Capability    string    `json:"capability"`     // 能力类型：text/image/video
    
    // Token 统计（文本生成）
    InputTokens   int       `json:"input_tokens"`
    OutputTokens  int       `json:"output_tokens"`
    TotalTokens   int       `json:"total_tokens"`
    
    // 请求统计
    RequestCount  int       `json:"request_count"`
    SuccessCount  int       `json:"success_count"`
    FailedCount   int       `json:"failed_count"`
    
    // 成本统计
    CostUSD       float64   `json:"cost_usd"`       // 成本（美元）
    
    Date          time.Time `json:"date"`           // 统计日期
    CreatedAt     time.Time `json:"created_at"`
}

// RecordUsage 记录使用情况
func (s *AIService) RecordUsage(config *models.AIServiceConfig, usage *TokenUsage, success bool) error {
    // 计算成本
    cost := s.calculateCost(config, usage)
    
    // 创建记录
    record := &models.AIUsage{
        ConfigID:     config.ID,
        Provider:     config.Provider,
        Model:        config.Model,
        Capability:   config.ProviderType,
        InputTokens:  usage.InputTokens,
        OutputTokens: usage.OutputTokens,
        TotalTokens:  usage.TotalTokens,
        RequestCount: 1,
        CostUSD:      cost,
        Date:         time.Now().Truncate(24 * time.Hour),
    }
    
    if success {
        record.SuccessCount = 1
    } else {
        record.FailedCount = 1
    }
    
    return s.db.Create(record).Error
}

// calculateCost 计算成本
func (s *AIService) calculateCost(config *models.AIServiceConfig, usage *TokenUsage) float64 {
    // 根据模型定价计算
    pricing := getModelPricing(config.Provider, config.Model)
    
    inputCost := float64(usage.InputTokens) * pricing.InputPricePer1K / 1000
    outputCost := float64(usage.OutputTokens) * pricing.OutputPricePer1K / 1000
    
    return inputCost + outputCost
}
```

---

## 4. 错误处理详解

### 4.1 API错误映射

```go
// pkg/ai/errors.go

package ai

import (
    "errors"
    "fmt"
)

// AI 错误类型
var (
    ErrRateLimit      = errors.New("rate limit exceeded")
    ErrInvalidAPIKey  = errors.New("invalid API key")
    ErrTimeout        = errors.New("request timeout")
    ErrContentFilter  = errors.New("content filtered")
    ErrInsufficientQuota = errors.New("insufficient quota")
    ErrModelNotFound  = errors.New("model not found")
    ErrServerError    = errors.New("server error")
)

// APIError API 错误结构
type APIError struct {
    Code    string
    Message string
    Status  int
    Raw     string
}

func (e *APIError) Error() string {
    return fmt.Sprintf("API Error [%s]: %s (Status: %d)", e.Code, e.Message, e.Status)
}

// MapHTTPError 将 HTTP 错误映射为 AI 错误
func MapHTTPError(statusCode int, body string) error {
    switch statusCode {
    case 401:
        return &APIError{
            Code:    "INVALID_API_KEY",
            Message: "API Key 无效或已过期",
            Status:  statusCode,
            Raw:     body,
        }
    case 429:
        return &APIError{
            Code:    "RATE_LIMIT",
            Message: "请求过于频繁，请稍后再试",
            Status:  statusCode,
            Raw:     body,
        }
    case 503, 502:
        return &APIError{
            Code:    "SERVER_ERROR",
            Message: "AI 服务暂时不可用",
            Status:  statusCode,
            Raw:     body,
        }
    default:
        if statusCode >= 400 {
            return &APIError{
                Code:    "API_ERROR",
                Message: fmt.Sprintf("API 请求失败 (状态码: %d)", statusCode),
                Status:  statusCode,
                Raw:     body,
            }
        }
        return nil
    }
}
```

### 4.2 限流处理

```go
// pkg/ai/ratelimit.go

package ai

import (
    "sync"
    "time"
)

// RateLimiter 令牌桶限流器
type RateLimiter struct {
    tokens    float64
    rate      float64     // 每秒产生令牌数
    burst     float64     // 桶容量
    lastTime  time.Time
    mu        sync.Mutex
}

// NewRateLimiter 创建限流器
func NewRateLimiter(requestsPerSecond int, burst int) *RateLimiter {
    return &RateLimiter{
        tokens:   float64(burst),
        rate:     float64(requestsPerSecond),
        burst:    float64(burst),
        lastTime: time.Now(),
    }
}

// Allow 检查是否允许请求
func (rl *RateLimiter) Allow() bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    now := time.Now()
    elapsed := now.Sub(rl.lastTime).Seconds()
    rl.lastTime = now
    
    // 补充令牌
    rl.tokens = min(rl.burst, rl.tokens+elapsed*rl.rate)
    
    if rl.tokens >= 1 {
        rl.tokens--
        return true
    }
    
    return false
}

// WaitTime 获取需要等待的时间
func (rl *RateLimiter) WaitTime() time.Duration {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    if rl.tokens >= 1 {
        return 0
    }
    
    // 计算需要等待的时间
    needed := 1 - rl.tokens
    waitSeconds := needed / rl.rate
    
    return time.Duration(waitSeconds * float64(time.Second))
}
```

在客户端中使用限流：

```go
type OpenAIClient struct {
    // ...
    rateLimiter *RateLimiter
}

func (c *OpenAIClient) GenerateText(prompt string, systemPrompt string, options ...func(*ChatCompletionRequest)) (string, error) {
    // 等待限流
    if waitTime := c.rateLimiter.WaitTime(); waitTime > 0 {
        time.Sleep(waitTime)
    }
    
    if !c.rateLimiter.Allow() {
        return "", ErrRateLimit
    }
    
    // 执行请求...
}
```

### 4.3 网络超时和重连

```go
// pkg/ai/client.go

import (
    "net"
    "net/http"
    "time"
)

// NewResilientHTTPClient 创建有弹性的 HTTP 客户端
func NewResilientHTTPClient(timeout time.Duration) *http.Client {
    return &http.Client{
        Timeout: timeout,
        Transport: &http.Transport{
            // 连接池配置
            MaxIdleConns:        100,
            MaxIdleConnsPerHost: 10,
            MaxConnsPerHost:     10,
            
            // 空闲连接超时
            IdleConnTimeout: 90 * time.Second,
            
            // TLS 握手超时
            TLSHandshakeTimeout: 10 * time.Second,
            
            // 建立连接超时
            DialContext: (&net.Dialer{
                Timeout:   10 * time.Second,
                KeepAlive: 30 * time.Second,
            }).DialContext,
            
            // 期望继续使用
            ExpectContinueTimeout: 1 * time.Second,
            
            // 强制使用 HTTP/2
            ForceAttemptHTTP2: true,
        },
    }
}
```

### 4.4 错误日志记录

```go
// application/services/ai_service.go

func (s *AIService) logAIError(config *models.AIServiceConfig, operation string, err error, prompt string) {
    // 判断错误类型
    var errCode string
    var shouldAlert bool
    
    switch {
    case errors.Is(err, ErrRateLimit):
        errCode = "RATE_LIMIT"
        shouldAlert = false  // 限流不需要告警
        
    case errors.Is(err, ErrInvalidAPIKey):
        errCode = "INVALID_API_KEY"
        shouldAlert = true   // API Key 错误需要告警
        
    case errors.Is(err, ErrTimeout):
        errCode = "TIMEOUT"
        shouldAlert = false
        
    default:
        errCode = "UNKNOWN"
        shouldAlert = true
    }
    
    // 记录结构化日志
    s.log.Errorw("AI 调用失败",
        "provider", config.Provider,
        "model", config.Model,
        "operation", operation,
        "error_code", errCode,
        "error", err,
        "should_alert", shouldAlert,
        "prompt_length", len(prompt),
    )
    
    // 如果需要告警，发送到告警系统
    if shouldAlert {
        s.sendAlert(config, operation, err)
    }
}
```

---

## 5. 性能优化

### 5.1 连接池配置

```go
// 针对不同提供商优化连接池
func createOptimizedHTTPClient(provider string, timeout time.Duration) *http.Client {
    transport := &http.Transport{
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: getIdleConnsPerHost(provider),
        IdleConnTimeout:     90 * time.Second,
        TLSHandshakeTimeout: 10 * time.Second,
    }
    
    return &http.Client{
        Timeout:   timeout,
        Transport: transport,
    }
}

func getIdleConnsPerHost(provider string) int {
    switch provider {
    case models.ProviderOpenAI:
        return 20  // OpenAI 支持高并发
    case models.ProviderDoubao:
        return 10  // 豆包适中
    case models.ProviderGemini:
        return 10
    default:
        return 5
    }
}
```

### 5.2 并发请求控制

```go
// pkg/ai/pool.go

package ai

import (
    "context"
    "sync"
)

// ConcurrencyPool 并发控制池
type ConcurrencyPool struct {
    sem chan struct{}
    wg  sync.WaitGroup
}

// NewConcurrencyPool 创建并发池
func NewConcurrencyPool(maxConcurrent int) *ConcurrencyPool {
    return &ConcurrencyPool{
        sem: make(chan struct{}, maxConcurrent),
    }
}

// Submit 提交任务
func (p *ConcurrencyPool) Submit(ctx context.Context, task func() error) error {
    select {
    case p.sem <- struct{}{}: // 获取信号量
        p.wg.Add(1)
        
        go func() {
            defer func() {
                <-p.sem // 释放信号量
                p.wg.Done()
            }()
            
            task()
        }()
        
        return nil
        
    case <-ctx.Done():
        return ctx.Err()
    }
}

// Wait 等待所有任务完成
func (p *ConcurrencyPool) Wait() {
    p.wg.Wait()
}

// 使用示例：批量图片生成
func (s *AIService) BatchGenerateImages(config *models.AIServiceConfig, prompts []string) ([]string, error) {
    pool := NewConcurrencyPool(5) // 最多5个并发
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
    defer cancel()
    
    results := make([]string, len(prompts))
    var mu sync.Mutex
    
    for i, prompt := range prompts {
        index := i
        p := prompt
        
        pool.Submit(ctx, func() error {
            client, err := s.GetClient(config)
            if err != nil {
                return err
            }
            
            urls, err := client.GenerateImage(p, "1024x1024", 1)
            if err != nil {
                return err
            }
            
            mu.Lock()
            if len(urls) > 0 {
                results[index] = urls[0]
            }
            mu.Unlock()
            
            return nil
        })
    }
    
    pool.Wait()
    
    return results, nil
}
```

### 5.3 缓存策略（提示词模板缓存）

```go
// application/services/prompt_cache.go

package services

import (
    "sync"
    "time"
    
    lru "github.com/hashicorp/golang-lru/v2"
)

// PromptCache 提示词缓存
type PromptCache struct {
    cache *lru.Cache[string, *CachedPrompt]
    mu    sync.RWMutex
}

// CachedPrompt 缓存的提示词
type CachedPrompt struct {
    Prompt    string
    Variables []string
    Version   int
    CreatedAt time.Time
}

// NewPromptCache 创建提示词缓存
func NewPromptCache(size int) *PromptCache {
    cache, _ := lru.New[string, *CachedPrompt](size)
    return &PromptCache{
        cache: cache,
    }
}

// Get 获取缓存的提示词
func (pc *PromptCache) Get(key string) (*CachedPrompt, bool) {
    return pc.cache.Get(key)
}

// Set 设置缓存
func (pc *PromptCache) Set(key string, prompt *CachedPrompt) {
    pc.cache.Add(key, prompt)
}

// GeneratePrompt 生成最终提示词（带缓存）
func (pc *PromptCache) GeneratePrompt(templateKey string, variables map[string]string) (string, error) {
    // 1. 获取模板
    template, ok := pc.Get(templateKey)
    if !ok {
        return "", fmt.Errorf("模板不存在: %s", templateKey)
    }
    
    // 2. 验证变量
    for _, v := range template.Variables {
        if _, ok := variables[v]; !ok {
            return "", fmt.Errorf("缺少变量: %s", v)
        }
    }
    
    // 3. 替换变量
    result := template.Prompt
    for key, value := range variables {
        result = strings.ReplaceAll(result, "{{"+key+"}}", value)
    }
    
    return result, nil
}

// PromptTemplate 提示词模板
var PromptTemplates = map[string]*CachedPrompt{
    "character_generation": {
        Prompt: `请根据以下信息生成一个角色描述：
角色名称: {{name}}
角色定位: {{role}}
年龄: {{age}}
性格特点: {{personality}}
外貌特征: {{appearance}}

请输出一段详细的角色描述，用于 AI 图片生成。`,
        Variables: []string{"name", "role", "age", "personality", "appearance"},
        Version:   1,
        CreatedAt: time.Now(),
    },
    "scene_generation": {
        Prompt: `请描述以下场景：
场景名称: {{name}}
时间: {{time}}
地点: {{location}}
氛围: {{atmosphere}}
关键元素: {{elements}}

请输出适合 AI 图片生成的详细场景描述。`,
        Variables: []string{"name", "time", "location", "atmosphere", "elements"},
        Version:   1,
        CreatedAt: time.Now(),
    },
}

// 初始化缓存
func init() {
    promptCache = NewPromptCache(100)
    for key, template := range PromptTemplates {
        promptCache.Set(key, template)
    }
}
```

---

## 6. AI服务使用最佳实践

### 6.1 提示词工程

```go
// 系统提示词模板
const (
    SystemPromptScriptGeneration = `你是一位专业的短剧编剧，擅长创作引人入胜的短剧剧本。
请遵循以下规则：
1. 剧本应该具有冲突、转折和情感张力
2. 对话要简洁有力，符合角色性格
3. 每集控制在3-5分钟时长
4. 场景描述要具体，便于视觉化`

    SystemPromptCharacterDesign = `你是一位角色设计专家，擅长设计有魅力的短剧角色。
请提供角色的：
1. 基本信息（姓名、年龄、职业）
2. 性格特点（3-5个关键词）
3. 外貌特征描述
4. 角色目标和动机
5. 角色弧光（角色成长变化）`
)

// BuildCharacterPrompt 构建角色生成提示词
func BuildCharacterPrompt(name, role, personality, appearance string) string {
    return fmt.Sprintf(`
角色名称: %s
角色定位: %s
性格特点: %s
外貌特征: %s

请设计一个适合短剧的角色形象描述。`,
        name, role, personality, appearance)
}
```

### 6.2 成本优化

```go
// CostOptimization 成本优化策略
type CostOptimization struct {
    // 选择合适的模型
    // 简单任务 -> GPT-3.5 (便宜)
    // 复杂任务 -> GPT-4 (质量好但贵)
    ModelTiers map[string][]string
}

func (co *CostOptimization) SelectModel(taskType string, complexity int) string {
    tiers := co.ModelTiers[taskType]
    
    // 根据复杂度选择模型层级
    if complexity <= 3 && len(tiers) >= 2 {
        return tiers[1] // 便宜模型
    }
    
    return tiers[0] // 高质量模型
}

// 成本优化配置
var CostOptimizedModels = CostOptimization{
    ModelTiers: map[string][]string{
        "text": {"gpt-4", "gpt-3.5-turbo"},
        "image": {"dall-e-3", "dall-e-2"},
    },
}
```

### 6.3 质量保证

```go
// QualityChecker 质量检查器
type QualityChecker struct {
    MinLength   int
    MaxLength   int
    BannedWords []string
}

// CheckScriptQuality 检查剧本质量
func (qc *QualityChecker) CheckScriptQuality(script string) error {
    // 1. 长度检查
    if len(script) < qc.MinLength {
        return fmt.Errorf("剧本太短，至少需要 %d 字符", qc.MinLength)
    }
    
    if len(script) > qc.MaxLength {
        return fmt.Errorf("剧本太长，最多允许 %d 字符", qc.MaxLength)
    }
    
    // 2. 敏感词检查
    for _, word := range qc.BannedWords {
        if strings.Contains(script, word) {
            return fmt.Errorf("包含敏感词: %s", word)
        }
    }
    
    // 3. 格式检查
    if !strings.Contains(script, "场景") {
        return fmt.Errorf("剧本缺少场景标记")
    }
    
    return nil
}
```

---

## 相关文档

- [01-环境搭建指南.md](./01-环境搭建指南.md)
- [02-代码规范.md](./02-代码规范.md)
- [03-DDD开发指南.md](./03-DDD开发指南.md)
- [04-API开发指南.md](./04-API开发指南.md)
