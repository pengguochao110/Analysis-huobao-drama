# 02-代码规范

本文档定义了火宝短剧项目的代码编写规范，确保代码风格统一、易于维护。

---

## 1. Go代码规范

### 1.1 命名规范

#### 包名 (kebab-case)

```go
// ✅ 正确
package storyboard_service
package ai_config
package video_merge

// ❌ 错误
package storyboardService  // 不要使用驼峰
package aiConfig           // 不要使用驼峰
package VideoMerge         // 不要使用大写开头
```

#### 类型/结构体 (CamelCase)

```go
// ✅ 正确
type DramaService struct {}
type CreateDramaRequest struct {}
type AIProvider interface {}

// ❌ 错误
type dramaService struct {}      // 首字母小写
type createDramaRequest struct {} // 首字母小写
type AI_Provider struct {}        // 不要使用下划线
```

#### 变量 (lowerCamelCase)

```go
// ✅ 正确
var dramaID uint
var storyboardCount int
var aiService *AIService

// ❌ 错误
var drama_id uint         // 不要使用蛇形命名
var StoryboardCount int   // 不要大写开头（除非导出）
var AIService *AIService  // 避免与类型同名
```

#### 常量 (UPPER_SNAKE_CASE)

```go
// ✅ 正确
const MAX_RETRY_COUNT = 3
const DEFAULT_TIMEOUT = 30 * time.Second
const STATUS_PENDING = "pending"

// ❌ 错误
const maxRetryCount = 3       // 常量使用全大写
const defaultTimeout = 30     // 常量使用全大写
const StatusPending = "pending" // 常量使用全大写
```

#### 接口命名

```go
// ✅ 正确 - 使用 "er" 后缀或明确描述
type AIProvider interface {}
type Repository interface {}
type VideoGenerator interface {}

// 或
type DramaRepository interface {}
type ImageService interface {}
```

### 1.2 文件组织

#### 每文件一个主要类型

```go
// ✅ 正确：drama_service.go 文件
type DramaService struct {}

func NewDramaService() *DramaService {}
func (s *DramaService) CreateDrama() {}
func (s *DramaService) GetDrama() {}

// ✅ 辅助类型可以放在同一文件
type CreateDramaRequest struct {}  // DTO 与 Service 放在一起
```

#### 文件长度限制

- **目标**：单个文件 < 500 行
- **警告**：超过 800 行需要重构
- **拆分策略**：按功能拆分（如 `storyboard_service.go` → `storyboard_service.go` + `storyboard_helper.go`）

### 1.3 错误处理

#### 早返回（Fail Fast）

```go
// ✅ 正确：早返回减少嵌套
func (s *DramaService) CreateDrama(req *CreateDramaRequest) (*models.Drama, error) {
    if req.Title == "" {
        return nil, errors.New("title is required")
    }
    
    if req.TotalEpisodes <= 0 {
        return nil, errors.New("invalid episode count")
    }
    
    // 主逻辑
    drama := &models.Drama{...}
    if err := s.db.Create(drama).Error; err != nil {
        return nil, fmt.Errorf("failed to create drama: %w", err)
    }
    
    return drama, nil
}

// ❌ 错误：深层嵌套
func (s *DramaService) CreateDrama(req *CreateDramaRequest) (*models.Drama, error) {
    if req.Title != "" {
        if req.TotalEpisodes > 0 {
            drama := &models.Drama{...}
            if err := s.db.Create(drama).Error; err == nil {
                return drama, nil
            } else {
                return nil, err
            }
        } else {
            return nil, errors.New("invalid episode count")
        }
    } else {
        return nil, errors.New("title is required")
    }
}
```

#### 错误包装

```go
// ✅ 正确：使用 fmt.Errorf 包装错误
if err := s.db.Create(drama).Error; err != nil {
    return nil, fmt.Errorf("failed to create drama: %w", err)
}

// 业务错误明确定义
var ErrDramaNotFound = errors.New("drama not found")
var ErrInvalidStatus = errors.New("invalid drama status")

// 使用时
if errors.Is(err, ErrDramaNotFound) {
    response.NotFound(c, "剧本不存在")
    return
}
```

#### 错误日志

```go
// ✅ 正确：记录完整上下文
if err := s.db.Create(drama).Error; err != nil {
    s.log.Errorw("Failed to create drama",
        "error", err,
        "title", req.Title,
        "episodes", req.TotalEpisodes,
    )
    return nil, fmt.Errorf("failed to create drama: %w", err)
}

// ❌ 错误：仅记录错误本身，缺少上下文
if err := s.db.Create(drama).Error; err != nil {
    s.log.Error(err)
    return nil, err
}
```

### 1.4 注释规范

#### 函数注释格式

```go
// CreateDrama 创建新剧本
// 参数：
//   - req: 创建请求，包含标题、描述等信息
// 返回：
//   - *models.Drama: 创建的剧本对象
//   - error: 创建过程中的错误
// 错误：
//   - ErrInvalidRequest: 请求参数无效
//   - ErrDatabaseError: 数据库操作失败
func (s *DramaService) CreateDrama(req *CreateDramaRequest) (*models.Drama, error) {
    // 实现...
}
```

#### 包注释

```go
// Package services 提供应用层业务逻辑服务
// 包含剧本、角色、分镜等核心业务逻辑实现
// 依赖领域层模型和基础设施层存储
package services
```

#### TODO/FIXME 标记

```go
// TODO: 添加事务支持，确保数据一致性
func (s *DramaService) BatchCreate(req *BatchRequest) error {
    // ...
}

// FIXME: 当前实现存在 N+1 查询问题，需要优化
func (s *DramaService) ListDramas() ([]models.Drama, error) {
    // ...
}

// OPTIMIZE: 考虑使用缓存减少数据库查询
func (s *DramaService) GetDramaStats() (*Stats, error) {
    // ...
}
```

### 1.5 导入顺序

```go
package handlers

import (
    // 标准库分组
    "encoding/json"
    "errors"
    "fmt"
    "net/http"
    "time"
    
    // 第三方库分组
    "github.com/gin-gonic/gin"
    "gorm.io/gorm"
    
    // 项目内库分组
    "github.com/drama-generator/backend/application/services"
    "github.com/drama-generator/backend/domain/models"
    "github.com/drama-generator/backend/pkg/config"
    "github.com/drama-generator/backend/pkg/logger"
    "github.com/drama-generator/backend/pkg/response"
)
```

### 1.6 代码示例（好 vs 坏）

#### 结构体定义

```go
// ✅ 好：清晰的标签、合理的字段顺序
type Drama struct {
    ID          uint           `gorm:"primaryKey;autoIncrement" json:"id"`
    Title       string         `gorm:"type:varchar(200);not null" json:"title"`
    Description *string        `gorm:"type:text" json:"description"`
    Status      string         `gorm:"type:varchar(20);default:'draft'" json:"status"`
    CreatedAt   time.Time      `gorm:"not null;autoCreateTime" json:"created_at"`
    UpdatedAt   time.Time      `gorm:"not null;autoUpdateTime" json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`
}

// ❌ 坏：缺少标签、字段顺序混乱
type Drama struct {
    description string
    Id int
    TITLE string
    created_at time.Time
}
```

#### 方法接收者

```go
// ✅ 好：使用指针接收者（可修改、避免拷贝）
func (s *DramaService) UpdateDrama(d *models.Drama) error {
    s.db.Save(d)
    return nil
}

// ✅ 好：只读操作使用值接收者
func (s DramaService) GetName() string {
    return s.name
}

// ❌ 坏：大结构体使用值接收者（性能问题）
func (s DramaService) Process() error {
    // DramaService 很大，拷贝成本高
}
```

---

## 2. Vue/TypeScript规范

### 2.1 组件命名

#### PascalCase

```vue
<!-- ✅ 正确 -->
<script setup lang="ts">
import DramaCard from './components/DramaCard.vue'
import StoryboardList from './components/StoryboardList.vue'
import AiConfigPanel from './components/AiConfigPanel.vue'
</script>

<!-- ❌ 错误 -->
<script setup lang="ts">
import dramaCard from './components/drama-card.vue'        // 驼峰
type storyboardList = ...                                 // 驼峰
import AIConfigPanel from './components/AIConfigPanel.vue' // 缩写大写
</script>
```

#### 语义化、多单词

```vue
<!-- ✅ 正确：清晰表达用途 -->
<DramaCard />
<CharacterImageUploader />
<VideoGenerationProgress />

<!-- ❌ 错误：过于简单或模糊 -->
<Card />          <!-- 太泛 -->
<Uploader />      <!-- 不明确上传什么 -->
<Progress />      <!-- 不明确什么进度 -->
<UI />            <!-- 无意义 -->
```

### 2.2 文件组织

#### 统一顺序

```vue
<!-- ✅ 正确：script → template → style -->
<script setup lang="ts">
// 1. 导入
import { ref, computed } from 'vue'

// 2. 类型定义
interface Props {
  dramaId: number
}

// 3. Props/Emits 定义
const props = defineProps<Props>()
const emit = defineEmits<{
  update: [value: string]
}>()

// 4. 响应式数据
const drama = ref<Drama | null>(null)
const loading = ref(false)

// 5. 计算属性
const isValid = computed(() => drama.value !== null)

// 6. 方法
const fetchDrama = async () => {
  // ...
}

// 7. 生命周期
onMounted(fetchDrama)
</script>

<template>
  <!-- 模板内容 -->
</template>

<style scoped>
/* 样式内容 */
</style>
```

### 2.3 TypeScript规范

#### 接口命名 (I前缀)

```typescript
// ✅ 正确
interface IDrama {
  id: number
  title: string
}

interface ICreateDramaRequest {
  title: string
  description?: string
}

// ❌ 错误
interface Drama { }        // 缺少 I 前缀（与类名冲突风险）
interface createRequest { } // 小写开头
```

#### 类型别名

```typescript
// ✅ 正确
type DramaStatus = 'draft' | 'planning' | 'production' | 'completed'
type ProviderType = 'openai' | 'gemini' | 'doubao'

// ❌ 错误
type status = string      // 过于宽泛，使用字面量类型
type anyType = any        // 避免使用 any
```

#### 避免any

```typescript
// ✅ 正确：明确类型
interface ApiResponse<T> {
  data: T
  message: string
}

const fetchDramas = async (): Promise<ApiResponse<Drama[]>> => {
  const response = await api.get('/dramas')
  return response.data
}

// ❌ 错误：使用 any
const fetchData = async (): Promise<any> => {
  return await api.get('/dramas')
}
```

### 2.4 响应式规范

#### ref vs reactive使用场景

```typescript
// ✅ ref：用于原始类型或需要替换的对象
const count = ref(0)
const drama = ref<Drama | null>(null)
const list = ref<string[]>([])

// ✅ reactive：用于复杂对象且不需要替换
const formState = reactive({
  title: '',
  description: '',
  episodes: []
})

// ❌ 错误：reactive 用于原始类型
const count = reactive({ value: 0 })  // 应该使用 ref(0)

// ❌ 错误：解构 reactive 对象
const { title } = formState  // 失去响应性
// 应该使用 toRefs(formState)
```

#### computed使用

```typescript
// ✅ 正确：简单计算
const fullName = computed(() => `${firstName.value} ${lastName.value}`)

// ✅ 正确：带 getter/setter
const dramaStatus = computed({
  get: () => drama.value?.status,
  set: (val) => {
    if (drama.value) drama.value.status = val
  }
})

// ❌ 错误：副作用计算（应该使用 watch）
const drama = computed(() => {
  fetchDrama()  // 副作用！
  return dramaStore.current
})
```

### 2.5 代码示例

#### 组件示例

```vue
<!-- DramaCard.vue -->
<script setup lang="ts">
import { computed } from 'vue'
import type { IDrama } from '@/types/drama'

// 类型定义
interface Props {
  drama: IDrama
  showActions?: boolean
}

interface Emits {
  (e: 'edit', id: number): void
  (e: 'delete', id: number): void
}

// Props & Emits
const props = withDefaults(defineProps<Props>(), {
  showActions: true
})

const emit = defineEmits<Emits>()

// 计算属性
const statusClass = computed(() => {
  const map: Record<string, string> = {
    draft: 'bg-gray-500',
    planning: 'bg-blue-500',
    production: 'bg-yellow-500',
    completed: 'bg-green-500'
  }
  return map[props.drama.status] || 'bg-gray-500'
})

// 方法
const handleEdit = () => {
  emit('edit', props.drama.id)
}

const handleDelete = () => {
  emit('delete', props.drama.id)
}
</script>

<template>
  <div class="drama-card p-4 rounded-lg shadow">
    <div class="flex items-center justify-between">
      <h3 class="text-lg font-bold">{{ drama.title }}</h3>
      <span :class="statusClass" class="px-2 py-1 rounded text-white text-sm">
        {{ drama.status }}
      </span>
    </div>
    <p class="text-gray-600 mt-2">{{ drama.description }}</p>
    
    <div v-if="showActions" class="mt-4 flex gap-2">
      <button @click="handleEdit" class="btn-primary">编辑</button>
      <button @click="handleDelete" class="btn-danger">删除</button>
    </div>
  </div>
</template>

<style scoped>
.drama-card {
  @apply bg-white transition-shadow hover:shadow-lg;
}
</style>
```

#### Composable 示例

```typescript
// useDrama.ts
import { ref, computed } from 'vue'
import type { IDrama } from '@/types/drama'
import { dramaApi } from '@/api/drama'

export function useDrama() {
  // 状态
  const dramas = ref<IDrama[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  // 计算属性
  const dramaCount = computed(() => dramas.value.length)
  const hasError = computed(() => error.value !== null)
  
  // 方法
  const fetchDramas = async () => {
    loading.value = true
    error.value = null
    
    try {
      const response = await dramaApi.getList()
      dramas.value = response.data
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
    } finally {
      loading.value = false
    }
  }
  
  const createDrama = async (data: Partial<IDrama>) => {
    loading.value = true
    try {
      const response = await dramaApi.create(data)
      dramas.value.push(response.data)
      return response.data
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  // 返回值
  return {
    dramas,
    loading,
    error,
    dramaCount,
    hasError,
    fetchDramas,
    createDrama
  }
}
```

---

## 3. DDD项目特定规范

### 3.1 目录结构规范

#### 文件放置规则

```
huobao-drama/
├── api/                    # API 层（接口层）
│   ├── handlers/          # HTTP 处理器
│   ├── middlewares/       # 中间件
│   └── routes/            # 路由配置
├── application/           # 应用层
│   └── services/          # 应用服务
├── domain/                # 领域层
│   └── models/            # 领域模型
├── infrastructure/        # 基础设施层
│   ├── database/          # 数据库实现
│   ├── storage/           # 存储实现
│   └── external/          # 外部服务
└── pkg/                   # 公共包
    ├── ai/                # AI 客户端
    ├── config/            # 配置
    ├── logger/            # 日志
    └── response/          # 响应封装
```

#### 禁止跨层引用

```go
// ✅ 正确：API 层依赖应用层
// api/handlers/drama.go
import "github.com/drama-generator/backend/application/services"

// ✅ 正确：应用层依赖领域层
// application/services/drama_service.go
import "github.com/drama-generator/backend/domain/models"

// ❌ 错误：API 层直接访问基础设施层
// api/handlers/drama.go
import "github.com/drama-generator/backend/infrastructure/database"  // 禁止！
```

### 3.2 包命名规范

#### 层名作为包名

```go
// ✅ 正确：包名体现所在层
// api/handlers/drama.go
package handlers

// application/services/drama_service.go
package services

// domain/models/drama.go
package models

// infrastructure/database/drama_repository.go
package database
```

#### 统一后缀

```go
// 服务实现
xxx_service.go      // 应用服务
xxx_repository.go   // 仓库实现
xxx_handler.go      // HTTP 处理器

// 领域模型
xxx.go              // 领域实体（不加后缀）
```

### 3.3 依赖方向

#### 严格遵循内层不依赖外层

```go
// ✅ 正确：domain 层不依赖任何其他层
// domain/models/drama.go
package models

import (
    "time"              // 仅依赖标准库
    "gorm.io/gorm"      // 可以依赖 ORM 标签
)

// ❌ 错误：domain 层依赖应用层
// domain/models/drama.go
import "github.com/drama-generator/backend/application/services"  // 禁止！
```

#### 依赖注入实现

```go
// ✅ 正确：通过构造函数注入依赖
// application/services/drama_service.go
type DramaService struct {
    db      *gorm.DB           // 基础设施通过接口注入
    log     *logger.Logger     // 日志服务
    baseURL string             // 配置值
}

func NewDramaService(db *gorm.DB, cfg *config.Config, log *logger.Logger) *DramaService {
    return &DramaService{
        db:      db,
        log:     log,
        baseURL: cfg.Storage.BaseURL,
    }
}

// ❌ 错误：全局变量
var db *gorm.DB  // 禁止全局数据库实例

func GetDrama() {
    db.Find(...)  // 依赖全局变量
}
```

### 3.4 Repository命名

```go
// ✅ 正确：领域层定义接口
// domain/models/repository.go (或单独文件)
type DramaRepository interface {
    FindByID(id uint) (*Drama, error)
    Save(drama *Drama) error
    Delete(id uint) error
    List(page, pageSize int) ([]Drama, int64, error)
}

// ✅ 正确：基础设施层实现
// infrastructure/database/drama_repository.go
type DramaRepositoryImpl struct {
    db *gorm.DB
}

func NewDramaRepository(db *gorm.DB) *DramaRepositoryImpl {
    return &DramaRepositoryImpl{db: db}
}

func (r *DramaRepositoryImpl) FindByID(id uint) (*models.Drama, error) {
    // 实现...
}
```

### 3.5 Service命名

```go
// ✅ 正确：应用服务命名
// application/services/drama_service.go
type DramaService struct { }

// 服务方法命名
func (s *DramaService) CreateDrama(req *CreateDramaRequest) (*models.Drama, error)
func (s *DramaService) GetDrama(id string) (*models.Drama, error)
func (s *DramaService) UpdateDrama(id string, req *UpdateDramaRequest) error
func (s *DramaService) DeleteDrama(id string) error
func (s *DramaService) ListDramas(query *DramaListQuery) ([]models.Drama, int64, error)

// ❌ 错误：过于简化或模糊的命名
func (s *DramaService) Create()        // 缺少对象说明
func (s *DramaService) Get()           // 缺少对象说明
func (s *DramaService) Do()            // 无意义
func (s *DramaService) Process()       // 过于模糊
```

---

## 4. 提交规范

### 4.1 Git Commit Message格式

使用 [Conventional Commits](https://www.conventionalcommits.org/) 规范：

```
<type>(<scope>): <subject>

<body>

<footer>
```

#### Type（必填）

| 类型 | 说明 |
|------|------|
| `feat` | 新功能 |
| `fix` | Bug 修复 |
| `docs` | 仅文档更改 |
| `style` | 代码格式修改（不影响功能） |
| `refactor` | 代码重构 |
| `perf` | 性能优化 |
| `test` | 添加或修改测试 |
| `chore` | 构建/工具链变动 |

#### Scope（可选）

| 范围 | 说明 |
|------|------|
| `api` | API 层代码 |
| `service` | 应用服务 |
| `model` | 领域模型 |
| `db` | 数据库相关 |
| `ui` | 前端界面 |
| `config` | 配置相关 |
| `deps` | 依赖更新 |

#### 示例

```bash
# 功能提交
feat(api): 添加剧本批量删除接口

添加 /api/v1/dramas/batch-delete 接口
支持批量删除剧本及其关联数据
包含事务处理和权限验证

Closes #123

# Bug 修复
fix(service): 修复视频生成超时问题

增加视频生成服务的超时时间至 5 分钟
添加重试机制处理临时网络故障

# 文档更新
docs(readme): 更新部署文档

添加 Docker 部署步骤说明
补充环境变量配置示例

# 代码重构
refactor(model): 重构剧本状态枚举

将字符串状态改为 Status 类型
添加状态转换验证方法
```

### 4.2 分支命名规范

#### 格式

```
<type>/<scope>/<description>
```

#### 示例

```bash
# 功能分支
feature/api/drama-batch-delete
feature/ui/storyboard-timeline
feature/service/ai-provider-factory

# 修复分支
fix/service/video-timeout
fix/db/connection-leak
fix/ui/mobile-layout

# 重构分支
refactor/model/status-enum
refactor/api/error-handling

# 文档分支
docs/deployment/docker
```

### 4.3 PR模板

创建 `.github/pull_request_template.md`：

```markdown
## 描述
<!-- 描述这个 PR 做了什么 -->

## 变更类型
- [ ] 新功能 (feat)
- [ ] Bug 修复 (fix)
- [ ] 文档更新 (docs)
- [ ] 代码重构 (refactor)
- [ ] 性能优化 (perf)
- [ ] 测试相关 (test)

## 检查清单
- [ ] 代码遵循项目代码规范
- [ ] 已添加/更新单元测试
- [ ] 已通过本地测试
- [ ] 已更新相关文档
- [ ] 无破坏性变更（或已在描述中说明）

## 关联 Issue
<!-- 关联相关的 Issue，例如: Fixes #123, Closes #456 -->

## 截图（如果适用）
<!-- UI 变更请提供截图 -->
```

---

## 5. 代码审查清单

### Go 代码审查

- [ ] 错误处理完整（早返回、错误包装）
- [ ] 日志记录包含足够上下文
- [ ] 没有使用全局变量
- [ ] 依赖方向正确（DDD 分层）
- [ ] 命名规范符合约定
- [ ] 注释清晰完整
- [ ] 无未处理的错误
- [ ] 资源正确释放（defer）

### Vue/TypeScript 代码审查

- [ ] 类型定义完整（无 any）
- [ ] 组件命名规范
- [ ] 响应式使用正确（ref/reactive）
- [ ] 无副作用的 computed
- [ ] Props/Emits 类型定义
- [ ] 样式使用 scoped

---

## 相关文档

- [01-环境搭建指南.md](./01-环境搭建指南.md)
- [03-DDD开发指南.md](./03-DDD开发指南.md)
- [04-API开发指南.md](./04-API开发指南.md)
