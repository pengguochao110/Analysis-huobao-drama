# 07-调试与排错

## 1. 日志系统详解

### 1.1 Zap日志框架配置

火宝短剧项目使用 Uber 的 Zap 高性能日志库，支持开发/生产双模式：

```go
// pkg/logger/logger.go
package logger

import (
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

type Logger struct {
	*zap.SugaredLogger
}

func NewLogger(debug bool) *Logger {
	var config zap.Config

	if debug {
		// 开发模式：彩色输出、人类可读
		config = zap.NewDevelopmentConfig()
		config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
		// 简化输出：禁用时间戳和调用者信息
		config.EncoderConfig.TimeKey = ""
		config.EncoderConfig.CallerKey = ""
	} else {
		// 生产模式：JSON格式、结构化日志
		config = zap.NewProductionConfig()
		config.EncoderConfig.TimeKey = "timestamp"
		config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
	}

	logger, err := config.Build()
	if err != nil {
		panic(err)
	}

	return &Logger{SugaredLogger: logger.Sugar()}
}
```

**配置对比**：

| 特性 | 开发模式 (debug=true) | 生产模式 (debug=false) |
|------|----------------------|----------------------|
| 格式 | 控制台彩色文本 | JSON结构化 |
| 时间戳 | 无 | ISO8601格式 |
| 日志级别 | Debug及以上 | Info及以上 |
| 调用者 | 隐藏 | 包含文件名和行号 |
| 性能 | 较低（便于调试） | 高（无反射） |

### 1.2 日志级别

```go
// 日志级别使用指南
log.Debug("调试信息，仅在开发时可见")
log.Debugw("带字段的调试", "drama_id", 123, "step", "outline")

log.Info("普通信息，记录正常流程")
log.Infow("创建短剧成功", "drama_id", drama.ID, "title", drama.Title)

log.Warn("警告信息，需要关注但非错误")
log.Warnw("API响应慢", "duration_ms", 5000, "endpoint", "/dramas")

log.Error("错误信息，需要处理")
log.Errorw("数据库操作失败", "error", err, "sql", sql)

log.Fatal("致命错误，程序退出")
log.Fatalw("无法启动服务器", "error", err, "port", 5678)
```

**级别选择原则**：
- **Debug**: 开发调试，线上关闭
- **Info**: 关键业务流程节点（创建、更新、删除成功）
- **Warn**: 非致命异常（API慢、重试、降级）
- **Error**: 需要人工介入的错误
- **Fatal**: 无法恢复的错误（配置错误、端口占用）

### 1.3 日志分类

```go
// 1. 访问日志 - API请求记录
// 由中间件自动记录
func LoggerMiddleware(log *logger.Logger) gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        c.Next()
        
        log.Infow("HTTP Request",
            "method", c.Request.Method,
            "path", c.Request.URL.Path,
            "status", c.Writer.Status(),
            "duration_ms", time.Since(start).Milliseconds(),
            "client_ip", c.ClientIP(),
        )
    }
}

// 2. 业务日志 - 核心业务流程
dramaService.log.Infow("Drama created",
    "drama_id", drama.ID,
    "title", drama.Title,
    "user_id", userID,
)

// 3. 错误日志 - 异常和错误
if err != nil {
    log.Errorw("Failed to generate script",
        "error", err,
        "drama_id", dramaID,
        "ai_provider", "openai",
        "prompt_length", len(prompt),
    )
}

// 4. 性能日志 - 耗时操作
start := time.Now()
// ... 耗时操作
log.Debugw("Image generation completed",
    "duration_ms", time.Since(start).Milliseconds(),
    "model", "dall-e-3",
)
```

### 1.4 JSON结构化日志

```go
// 生产环境输出示例
{
  "level": "info",
  "timestamp": "2024-01-15T10:30:00.123Z",
  "caller": "services/drama_service.go:72",
  "msg": "Drama created",
  "drama_id": 123,
  "title": "我的短剧",
  "genre": "喜剧"
}

// 错误日志输出示例
{
  "level": "error",
  "timestamp": "2024-01-15T10:35:00.456Z",
  "caller": "services/ai_service.go:156",
  "msg": "AI API call failed",
  "error": "rate limit exceeded",
  "provider": "openai",
  "retry_count": 3,
  "drama_id": 123
}
```

### 1.5 日志分析技巧

```bash
# grep - 快速搜索
# 查找特定短剧的日志
grep '"drama_id": 123' app.log

# 查找错误日志
grep -i 'error' app.log

# 查找特定时间范围
grep '2024-01-15T10:3' app.log

# awk - 字段提取
# 提取所有API请求路径和耗时
awk '/HTTP Request/{print $5, $9}' app.log

# 统计各状态码数量
awk '/HTTP Request/{print $7}' app.log | sort | uniq -c

# 计算平均响应时间
awk '/HTTP Request/{sum+=$9; count++} END {print "Avg:", sum/count"ms"}' app.log

# jq - JSON日志处理（推荐）
# 过滤特定级别日志
cat app.log | jq 'select(.level == "error")'

# 提取特定字段
cat app.log | jq '{time: .timestamp, msg: .msg, error: .error}'

# 统计错误类型
cat app.log | jq -r 'select(.level == "error").error' | sort | uniq -c

# 查找特定短剧的所有相关日志
cat app.log | jq 'select(.drama_id == 123)'

# 计算各API端点平均响应时间
cat app.log | jq -s '
  group_by(.path) |
  map({
    path: .[0].path,
    avg_duration: (map(.duration_ms) | add / length),
    count: length
  })
'
```

### 1.6 日志轮转

```go
// 使用 lumberjack 实现日志轮转
import (
    "gopkg.in/natefinch/lumberjack.v2"
    "go.uber.org/zap/zapcore"
)

func NewFileLogger(debug bool) *Logger {
    // 配置日志切割
    lumberjackLogger := &lumberjack.Logger{
        Filename:   "logs/app.log",    // 日志文件路径
        MaxSize:    100,                // 单个文件最大100MB
        MaxBackups: 30,                 // 保留30个备份
        MaxAge:     7,                  // 保留7天
        Compress:   true,               // 压缩旧日志
    }

    encoder := zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())
    core := zapcore.NewCore(
        encoder,
        zapcore.AddSync(lumberjackLogger),
        zapcore.InfoLevel,
    )

    return &Logger{SugaredLogger: zap.New(core).Sugar()}
}
```

## 2. 调试工具配置

### 2.1 Delve (Go调试器)

#### 安装与基础使用

```bash
# 安装Delve
go install github.com/go-delve/delve/cmd/dlv@latest

# 调试运行中的程序
dlv attach <pid>

# 调试程序启动
dlv debug main.go

# 调试测试
dlv test ./application/services/
```

#### 常用调试命令

```bash
# 启动调试
dlv debug main.go

# 断点命令
(dlv) break main.go:25          # 在25行设置断点
(dlv) break DramaService.CreateDrama  # 在函数入口断点
(dlv) clear 1                   # 清除1号断点
(dlv) clearall                  # 清除所有断点

# 执行控制
(dlv) continue    或  c         # 继续执行
(dlv) next        或  n         # 下一行（不进入函数）
(dlv) step        或  s         # 步入函数
(dlv) stepout     或  so        # 步出函数
(dlv) restart                   # 重启程序
(dlv) quit        或  q         # 退出调试

# 查看变量
(dlv) print drama               # 打印变量值
(dlv) locals                    # 显示所有局部变量
(dlv) args                      # 显示函数参数
(dlv) vars                      # 显示所有包变量

# 堆栈跟踪
(dlv) stack       或  bt        # 显示调用栈
(dlv) frame 2                   # 切换到第2帧
(dlv) up                        # 向上一层
(dlv) down                      # 向下一层

# 条件断点
(dlv) break drama_service.go:50 if drama.ID == 123
(dlv) break DramaService.UpdateDrama if req.Title == ""

# 监视点（变量变化时暂停）
(dlv) watch -w drama.Status
```

### 2.2 VS Code调试配置

```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    // 1. Go后端调试
    {
      "name": "Go: Launch Backend",
      "type": "go",
      "request": "launch",
      "mode": "auto",
      "program": "${workspaceFolder}/main.go",
      "env": {
        "DEBUG": "true"
      },
      "args": [],
      "showLog": true
    },
    {
      "name": "Go: Attach to Process",
      "type": "go",
      "request": "attach",
      "mode": "local",
      "processId": 0  // 替换为实际进程ID
    },
    {
      "name": "Go: Debug Test",
      "type": "go",
      "request": "launch",
      "mode": "test",
      "program": "${workspaceFolder}/application/services",
      "args": ["-test.run", "TestDramaService"]
    },
    
    // 2. Vue前端调试
    {
      "name": "Vue: Chrome Debug",
      "type": "chrome",
      "request": "launch",
      "url": "http://localhost:5173",
      "webRoot": "${workspaceFolder}/web",
      "pathMapping": {
        "/@fs/": "${workspaceFolder}/"
      },
      "sourceMapPathOverrides": {
        "webpack:///src/*": "${webRoot}/src/*"
      }
    },
    {
      "name": "Vue: Edge Debug",
      "type": "msedge",
      "request": "launch",
      "url": "http://localhost:5173",
      "webRoot": "${workspaceFolder}/web"
    },
    
    // 3. 全栈调试（同时启动前后端）
    {
      "name": "Full Stack: Launch All",
      "type": "compound",
      "configurations": ["Go: Launch Backend", "Vue: Chrome Debug"],
      "stopAll": true
    }
  ]
}
```

**VS Code调试快捷键**：
- `F5` - 开始调试
- `F9` - 切换断点
- `F10` - 单步跳过
- `F11` - 单步进入
- `Shift+F11` - 单步退出
- `Shift+F5` - 停止调试
- `Ctrl+Shift+D` - 打开调试面板

### 2.3 浏览器开发者工具

#### Network面板调试API

```javascript
// 检查API请求
// 1. 打开DevTools → Network
// 2. 勾选 Preserve log（保留日志）
// 3. 执行操作，观察请求：
//    - 请求URL和Method
//    - Status Code
//    - Response Time
//    - Request/Response Headers
//    - Request/Response Body

// 模拟慢网络
// Network → Throttling → Slow 3G/Fast 3G

// 复制请求为curl
// 右键请求 → Copy → Copy as cURL

// 重放请求
// 右键请求 → Replay XHR
```

#### Vue DevTools调试

```javascript
// 1. 安装Vue DevTools浏览器扩展
// 2. 打开DevTools → Vue 面板

// 查看组件树
// - 检查组件props、data、computed
// - 查看组件events
// - 检查组件slots

// 状态管理调试
// - Vuex/Pinia面板查看store状态
// - 时间旅行调试（撤销/重做状态变化）
// - 导出/导入状态快照

// 性能调试
// - Performance面板记录性能
// - 查看组件渲染时间
// - 识别重复渲染
```

#### 性能分析

```javascript
// Chrome Performance面板
// 1. 按 Ctrl+Shift+E 开始记录
// 2. 执行需要分析的操作
// 3. 停止记录
// 4. 分析：
//    - FPS图表（绿色=60fps）
//    - CPU使用率
//    - Network瀑布图
//    - Main线程长任务
//    - 内存堆快照

// 内存泄漏检测
// Memory面板 → Heap snapshot
// 对比多个时间点的内存快照
// 查看Retainers找出泄露源
```

### 2.4 API调试工具

```bash
# curl - 命令行API测试

# GET请求
curl http://localhost:5678/api/v1/dramas

# 带参数
curl "http://localhost:5678/api/v1/dramas?page=1&page_size=10"

# POST请求（JSON）
curl -X POST http://localhost:5678/api/v1/dramas \
  -H "Content-Type: application/json" \
  -d '{"title": "测试短剧", "description": "描述"}'

# PUT请求
curl -X PUT http://localhost:5678/api/v1/dramas/1 \
  -H "Content-Type: application/json" \
  -d '{"title": "更新标题"}'

# DELETE请求
curl -X DELETE http://localhost:5678/api/v1/dramas/1

# 下载文件
curl -O http://localhost:5678/api/v1/dramas/1/export

# 显示响应头
curl -I http://localhost:5678/api/v1/dramas

# 详细输出
curl -v http://localhost:5678/api/v1/dramas

# 保存cookie
curl -c cookies.txt http://localhost:5678/api/v1/login

# 使用cookie
curl -b cookies.txt http://localhost:5678/api/v1/dramas
```

```bash
# httpie - 更友好的API工具
# 安装: pip install httpie

# GET
http GET localhost:5678/api/v1/dramas

# GET带参数
http GET localhost:5678/api/v1/dramas page==1 page_size==10

# POST（自动JSON）
http POST localhost:5678/api/v1/dramas \
  title="测试短剧" \
  description="描述"

# 预览请求（不发送）
http --print=Hh POST localhost:5678/api/v1/dramas title="测试"

# 下载
http -d GET localhost:5678/api/v1/dramas/1/export
```

### 2.5 数据库调试

```bash
# SQLite命令行调试
sqlite3 data/drama.db

# 常用命令
.help           # 显示帮助
.tables         # 显示所有表
.schema dramas  # 显示表结构
.headers on     # 显示列名
.mode column    # 列对齐模式
.mode json      # JSON输出
.timer on       # 显示执行时间

# 查询示例
SELECT * FROM dramas WHERE id = 1;
SELECT id, title, status FROM dramas ORDER BY updated_at DESC LIMIT 10;
SELECT status, COUNT(*) FROM dramas GROUP BY status;

# 分析查询性能
EXPLAIN QUERY PLAN SELECT * FROM dramas WHERE title LIKE '%测试%';

# 导出数据
.mode csv
.output dramas.csv
SELECT * FROM dramas;
.output stdout

# 导入数据
.import dramas.csv dramas

# 退出
.quit
```

```go
// GORM调试：打印SQL语句
// 配置文件中设置

database:
  log_level: info    # silent/error/warn/info/debug
  
// 或在代码中动态开启
func DebugGORM(db *gorm.DB) *gorm.DB {
    return db.Debug()  // 打印所有SQL
}

// 查看慢查询
sqlDB, err := db.DB()
sqlDB.SetConnMaxLifetime(time.Hour)

// 启用慢查询日志
db.Logger = logger.New(
    log.New(os.Stdout, "\r\n", log.LstdFlags),
    logger.Config{
        SlowThreshold: 200 * time.Millisecond,  // 慢查询阈值
        LogLevel:      logger.Info,
        Colorful:      true,
    },
)
```

## 3. 常见问题速查手册

### 3.1 数据库问题

#### "database is locked"（SQLite并发）

```go
// 问题：SQLite并发写入导致锁定
// 错误信息：database is locked

// 解决方案1：使用连接池限制并发
db, err := gorm.Open(sqlite.Open("drama.db"), &gorm.Config{})
sqlDB, _ := db.DB()
sqlDB.SetMaxOpenConns(1)  // SQLite只支持单连接写入

// 解决方案2：使用WAL模式
sqlDB.Exec("PRAGMA journal_mode=WAL;")

// 解决方案3：增加超时时间
// 使用连接字符串
db, err := gorm.Open(sqlite.Open("drama.db?_busy_timeout=5000"), nil)
```

#### 连接池耗尽

```go
// 症状：大量请求时响应变慢或失败
// 诊断：查看日志中的慢查询或连接超时

// 解决方案
sqlDB, _ := db.DB()
sqlDB.SetMaxOpenConns(25)      // 最大打开连接
sqlDB.SetMaxIdleConns(10)      // 最大空闲连接
sqlDB.SetConnMaxLifetime(1 * time.Hour)  // 连接最大生命周期

// 监控连接池状态
var stats sql.DBStats
stats = sqlDB.Stats()
log.Infow("DB Pool Stats",
    "open_connections", stats.OpenConnections,
    "in_use", stats.InUse,
    "idle", stats.Idle,
    "wait_count", stats.WaitCount,
)
```

#### 查询慢（索引缺失）

```bash
# 诊断：使用EXPLAIN QUERY PLAN
sqlite> EXPLAIN QUERY PLAN 
   ...> SELECT * FROM dramas WHERE status = 'draft';

# 如果看到SCAN TABLE，说明缺少索引

# 解决方案：添加索引
db.Exec("CREATE INDEX idx_dramas_status ON dramas(status);")

# 复合索引
CREATE INDEX idx_storyboards_episode_number ON storyboards(episode_id, storyboard_number);
```

#### 迁移失败

```go
// 问题1：列已存在
// 解决：使用AutoMigrate的自动处理
// GORM AutoMigrate会自动跳过已存在的列

// 问题2：外键约束失败
// 诊断：检查关联表是否存在
// 解决：确保表创建顺序正确

// 问题3：数据类型不兼容
// 解决：手动编写迁移脚本
type Migrator struct {
    db *gorm.DB
}

func (m *Migrator) MigrateV2() error {
    // 添加新列
    if !m.db.Migrator().HasColumn(&models.Drama{}, "style") {
        m.db.Exec("ALTER TABLE dramas ADD COLUMN style varchar(50) DEFAULT 'realistic';")
    }
    return nil
}
```

### 3.2 AI服务问题

#### API Key无效

```bash
# 症状：401 Unauthorized 或认证错误
# 诊断步骤：

# 1. 检查配置文件
cat configs/config.yaml | grep -i api_key

# 2. 验证环境变量
echo $OPENAI_API_KEY

# 3. 测试API Key
curl https://api.openai.com/v1/models \
  -H "Authorization: Bearer $OPENAI_API_KEY"

# 解决方案：
# - 检查Key是否过期
# - 确认Key有对应服务的权限
# - 验证Key格式（去除多余空格）
```

#### 请求超时

```go
// 文本生成：30秒
// 图像生成：120秒
// 视频生成：300秒

// 配置超时
httpClient := &http.Client{
    Timeout: 120 * time.Second,  // 根据服务调整
}

// 区分超时类型
type Config struct {
    APITimeout struct {
        Text  time.Duration `default:"30s"`
        Image time.Duration `default:"120s"`
        Video time.Duration `default:"300s"`
    }
}

// 处理超时错误
if err != nil {
    if os.IsTimeout(err) || errors.Is(err, context.DeadlineExceeded) {
        log.Warnw("AI API timeout", "service", "image", "drama_id", dramaID)
        // 重试或返回友好错误
        return ErrAITimeout
    }
}
```

#### 限流（429错误）

```go
// 实现指数退避重试
func CallAIWithRetry(ctx context.Context, fn func() error) error {
    const maxRetries = 3
    baseDelay := 1 * time.Second
    
    for i := 0; i < maxRetries; i++ {
        err := fn()
        if err == nil {
            return nil
        }
        
        // 检查是否是429错误
        if isRateLimitError(err) {
            delay := baseDelay * time.Duration(1<<i)  // 指数退避
            log.Warnw("Rate limited, retrying", "attempt", i+1, "delay", delay)
            time.Sleep(delay)
            continue
        }
        
        return err
    }
    
    return fmt.Errorf("max retries exceeded")
}

// 请求限流器
import "golang.org/x/time/rate"

var limiter = rate.NewLimiter(rate.Every(time.Second), 10)  // 每秒10个

func CallAI(ctx context.Context) error {
    if err := limiter.Wait(ctx); err != nil {
        return err
    }
    // 执行API调用
}
```

#### 响应解析失败

```go
// 症状：JSON解析错误或字段缺失

// 防御式编程
func ParseAIResponse(rawJSON string) (*AIResponse, error) {
    var response AIResponse
    
    // 1. 检查空响应
    if rawJSON == "" {
        return nil, ErrEmptyResponse
    }
    
    // 2. 尝试解析
    if err := json.Unmarshal([]byte(rawJSON), &response); err != nil {
        log.Errorw("Failed to parse AI response",
            "error", err,
            "raw_response", rawJSON[:min(500, len(rawJSON))],
        )
        return nil, ErrParseFailed
    }
    
    // 3. 验证必填字段
    if response.Content == "" {
        return nil, ErrMissingContent
    }
    
    return &response, nil
}

// 记录原始响应用于调试
log.Debugw("AI raw response", "response", rawJSON)
```

### 3.3 视频处理问题

#### FFmpeg未找到

```bash
# 症状：exec: "ffmpeg": executable file not found

# 检查FFmpeg安装
which ffmpeg
ffmpeg -version

# Docker环境确保包含FFmpeg
# Dockerfile中：
RUN apk add --no-cache ffmpeg

# 代码中检查
func init() {
    _, err := exec.LookPath("ffmpeg")
    if err != nil {
        log.Fatal("ffmpeg not found in PATH")
    }
}

# 指定FFmpeg路径
type Config struct {
    FFmpegPath string `default:"ffmpeg"`  // 或使用绝对路径
}
```

#### 视频格式不支持

```go
// 支持的格式检查
var supportedFormats = map[string]bool{
    ".mp4":  true,
    ".mov":  true,
    ".avi":  true,
    ".webm": true,
}

func ValidateVideoFormat(filename string) error {
    ext := strings.ToLower(filepath.Ext(filename))
    if !supportedFormats[ext] {
        return fmt.Errorf("unsupported video format: %s", ext)
    }
    return nil
}

// FFmpeg转换
func ConvertToMP4(inputPath, outputPath string) error {
    cmd := exec.Command("ffmpeg",
        "-i", inputPath,
        "-c:v", "libx264",
        "-c:a", "aac",
        "-y",
        outputPath,
    )
    return cmd.Run()
}
```

#### 内存不足（大视频处理）

```go
// 症状：OOMKilled 或内存溢出

// 解决方案1：分段处理
func ProcessLargeVideo(inputPath string) error {
    // 获取视频信息
    duration := getVideoDuration(inputPath)
    
    // 分段处理（每段30秒）
    segmentDuration := 30
    for start := 0; start < duration; start += segmentDuration {
        end := min(start+segmentDuration, duration)
        segment := extractSegment(inputPath, start, end)
        processSegment(segment)
        // 清理临时文件
        os.Remove(segment)
    }
    return nil
}

// 解决方案2：流式处理
func StreamProcess(inputPath string) error {
    cmd := exec.Command("ffmpeg",
        "-i", inputPath,
        "-f", "segment",
        "-segment_time", "30",
        "output_%03d.mp4",
    )
    return cmd.Run()
}

// 解决方案3：限制并发
var videoSemaphore = make(chan struct{}, 2)  // 最多2个并发

func ProcessVideo(inputPath string) error {
    videoSemaphore <- struct{}{}  // 获取许可
    defer func() { <-videoSemaphore }()  // 释放许可
    
    // 处理视频
}
```

### 3.4 前端问题

#### 跨域错误（CORS）

```bash
# 症状：CORS policy: No 'Access-Control-Allow-Origin'

# 解决方案1：后端配置CORS中间件
// api/middlewares/cors.go
func CORSMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
        c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}

// 解决方案2：开发环境代理
// vite.config.ts
export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:5678',
        changeOrigin: true,
      },
    },
  },
})
```

#### 路由404

```typescript
// 症状：刷新页面后404

// 解决方案：配置history模式回退
// vite.config.ts
export default defineConfig({
  server: {
    historyApiFallback: true,
  },
})

// Nginx配置
location / {
    try_files $uri $uri/ /index.html;
}

// 确保路由定义正确
const routes = [
  {
    path: '/dramas/:id',
    name: 'DramaDetail',
    component: () => import('@/views/drama/DramaDetail.vue'),
  },
]
```

#### 状态管理混乱（Pinia）

```typescript
// 症状：状态更新但视图不刷新

// 解决方案1：确保响应式
// ❌ 错误：直接替换整个对象
store.episode = newEpisode  // 可能丢失响应式

// ✅ 正确：使用Object.assign或patch
store.$patch({ episode: newEpisode })
// 或
Object.assign(store.episode, newEpisode)

// 解决方案2：正确使用store
// ❌ 错误：解构失去响应式
const { episode } = store  // episode不是响应式的

// ✅ 正确：使用computed或storeToRefs
import { storeToRefs } from 'pinia'
const { episode } = storeToRefs(store)
// 或
const episode = computed(() => store.episode)

// 解决方案3：调试工具
// 在浏览器控制台
const store = __VUE_PINIA__.state.value.episode
store.$patch({ count: 1 })
store.$reset()
```

#### 内存泄漏

```typescript
// 症状：页面长时间运行后变卡

// 解决方案1：清理定时器
const timer = setInterval(() => {}, 1000)
onUnmounted(() => {
  clearInterval(timer)
})

// 解决方案2：取消请求
const controller = new AbortController()
request.get('/api/data', { signal: controller.signal })
onUnmounted(() => {
  controller.abort()
})

// 解决方案3：移除事件监听
const handler = () => {}
window.addEventListener('resize', handler)
onUnmounted(() => {
  window.removeEventListener('resize', handler)
})

// 解决方案4：清理DOM引用
const elRef = ref<HTMLElement>()
onUnmounted(() => {
  elRef.value = undefined
})
```

### 3.5 部署问题

#### 端口占用

```bash
# 症状：bind: address already in use

# 查找占用端口的进程
# Linux/Mac
lsof -i :5678
netstat -tlnp | grep 5678

# Windows
netstat -ano | findstr :5678

# 终止进程
# Linux/Mac
kill -9 <PID>

# Windows
taskkill /PID <PID> /F

# 或更换端口
./huobao-drama --port 5679
```

#### 权限不足（文件写入）

```bash
# 症状：permission denied

# 检查权限
ls -la /app/data/

# 解决方案1：修改目录权限
chmod 755 /app/data
chown -R $(whoami) /app/data

# 解决方案2：Docker使用非root用户
# Dockerfile
RUN useradd -m appuser && chown -R appuser:appuser /app/data
USER appuser

# 解决方案3：挂载卷时指定权限
docker run -v $(pwd)/data:/app/data:rw huobao-drama
```

#### 环境变量缺失

```bash
# 症状：配置项为默认值或panic

# 诊断
# 检查环境变量
echo $HUOBAO_PORT
echo $HUOBAO_DB_PATH

# Docker中查看
docker exec <container_id> env

# 解决方案1：使用.env文件
# .env
HUOBAO_PORT=5678
HUOBAO_DB_PATH=/app/data/drama.db

# 解决方案2：Docker Compose
services:
  app:
    environment:
      - HUOBAO_PORT=5678
    env_file:
      - .env

# 解决方案3：代码中添加默认值
type Config struct {
    Port string `envconfig:"PORT" default:"5678"`
}
```

## 4. 性能调试

### 4.1 pprof使用

```go
// 启用pprof（main.go）
import _ "net/http/pprof"

go func() {
    log.Println(http.ListenAndServe("localhost:6060", nil))
}()
```

#### CPU分析

```bash
# 收集30秒CPU数据
curl http://localhost:6060/debug/pprof/profile?seconds=30 > cpu.pprof

# 分析
go tool pprof cpu.pprof

# 常用命令
(pprof) top          # 显示Top10热点
(pprof) top 20       # 显示Top20
(pprof) list <func>  # 查看函数详情
(pprof) web          # 生成SVG火焰图
(pprof) png          # 生成PNG火焰图

# 生成火焰图
go tool pprof -http=:8080 cpu.pprof
```

#### 内存分析

```bash
# 收集内存数据
curl http://localhost:6060/debug/pprof/heap > heap.pprof

# 分析内存分配
go tool pprof heap.pprof
(pprof) top
(pprof) list DramaService.GetDrama

# 查看内存占用
curl http://localhost:6060/debug/pprof/allocs?seconds=30 > allocs.pprof
```

#### Goroutine分析

```bash
# 查看所有goroutine
curl http://localhost:6060/debug/pprof/goroutine > goroutine.pprof

# 查看goroutine数量
curl http://localhost:6060/debug/pprof/goroutine?debug=1

# 查找goroutine泄露
# 比较两个时间点的goroutine dump
diff <(curl -s http://localhost:6060/debug/pprof/goroutine?debug=1) \
     <(sleep 60 && curl -s http://localhost:6060/debug/pprof/goroutine?debug=1)
```

### 4.2 火焰图解读

```bash
# 生成火焰图
go tool pprof -http=:8080 cpu.pprof

# 火焰图阅读指南：
# - 宽度 = 占用CPU时间（越宽越耗时）
# - 高度 = 调用栈深度
# - 颜色 = 无意义，仅区分
# - 从下往上 = 调用顺序

# 解读示例：
# 1. 找最宽的 plateau（平顶）
# 2. 这是优化的重点
# 3. 点击可以放大查看

# 对比不同时间点的火焰图
go tool pprof -http=:8080 -base baseline.pprof current.pprof
```

### 4.3 慢查询分析

```go
// 启用GORM慢查询日志
import "gorm.io/gorm/logger"

newLogger := logger.New(
    log.New(os.Stdout, "\r\n", log.LstdFlags),
    logger.Config{
        SlowThreshold: 100 * time.Millisecond,
        LogLevel:      logger.Warn,
        Colorful:      true,
    },
)

db, err := gorm.Open(sqlite.Open("drama.db"), &gorm.Config{
    Logger: newLogger,
})

// 慢查询日志输出示例：
// [warn] slow sql: SELECT * FROM storyboards WHERE episode_id = 1
// [cost: 250ms] [rows: 1000]
```

### 4.4 内存泄漏检测

```go
// 1. 添加内存监控端点
http.HandleFunc("/debug/memory", func(w http.ResponseWriter, r *http.Request) {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    json.NewEncoder(w).Encode(map[string]interface{}{
        "alloc_mb":        m.Alloc / 1024 / 1024,
        "total_alloc_mb":  m.TotalAlloc / 1024 / 1024,
        "sys_mb":          m.Sys / 1024 / 1024,
        "num_gc":          m.NumGC,
        "goroutines":      runtime.NumGoroutine(),
    })
})

// 2. 定期记录内存使用
go func() {
    for range time.Tick(1 * time.Minute) {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        log.Infow("Memory stats",
            "alloc_mb", m.Alloc/1024/1024,
            "goroutines", runtime.NumGoroutine(),
        )
    }
}()
```

### 4.5 并发瓶颈分析

```go
// 使用race detector检测竞态条件
go test -race ./...
go run -race main.go

// 使用mutex profile分析锁竞争
curl http://localhost:6060/debug/pprof/mutex > mutex.pprof

// 使用block profile分析阻塞
curl http://localhost:6060/debug/pprof/block?seconds=30 > block.pprof
```

## 5. 故障排查流程

### 5.1 问题定位步骤

```
┌─────────────────────────────────────────────────────────────┐
│  故障排查流程图                                               │
└─────────────────────────────────────────────────────────────┘

1. 确认现象
   ├─ 用户报告什么异常？
   ├─ 能否复现？
   └─ 影响范围多大？
         ↓
2. 收集信息
   ├─ 查看错误日志
   ├─ 查看系统监控
   ├─ 询问用户操作步骤
   └─ 检查最近变更
         ↓
3. 初步判断
   ├─ 应用层错误？→ 查看应用日志
   ├─ 数据库错误？→ 检查数据库状态
   ├─ 网络错误？→ 测试网络连通性
   └─ 资源不足？→ 查看系统资源
         ↓
4. 深入分析
   ├─ 添加调试日志
   ├─ 使用调试工具
   ├─ 分析堆栈信息
   └─ 检查配置参数
         ↓
5. 制定方案
   ├─ 临时缓解措施
   └─ 根本解决方案
         ↓
6. 验证修复
   ├─ 测试验证
   ├─ 监控观察
   └─ 记录复盘
```

### 5.2 最小复现案例

```go
// 遇到问题时，创建一个最小复现程序
// reproduce_test.go

package main

import (
    "testing"
    "fmt"
)

// 最小复现程序
func TestReproduceIssue(t *testing.T) {
    // 精确的环境设置
    db := setupMinimalDB()
    
    // 精确的输入数据
    drama := createDrama(db, "测试短剧")
    
    // 精确的操作步骤
    err := operationThatFails(drama.ID)
    
    // 验证问题存在
    if err == nil {
        t.Fatal("expected error but got nil")
    }
    
    fmt.Printf("Reproduced: %v\n", err)
}

// 最小复现的HTTP请求
func TestReproduceAPI(t *testing.T) {
    // 启动最小服务器
    srv := httptest.NewServer(createHandler())
    defer srv.Close()
    
    // 发送触发问题的请求
    resp, _ := http.Post(srv.URL+"/api/v1/dramas", 
        "application/json",
        strings.NewReader(`{"title": "`+strings.Repeat("x", 10000)+`"}`),
    )
    
    // 验证问题
    if resp.StatusCode != 413 {
        t.Fatalf("expected 413, got %d", resp.StatusCode)
    }
}
```

### 5.3 远程调试技巧

```bash
# 场景：生产环境偶发问题

# 1. 启用远程pprof（安全方式）
# 通过SSH隧道暴露pprof
ssh -L 6060:localhost:6060 user@remote-server

# 本地访问远程pprof
open http://localhost:6060/debug/pprof

# 2. 日志实时监控
ssh user@remote-server "tail -f /app/logs/app.log" | grep ERROR

# 3. 动态开启调试日志
# 通过API接口动态调整日志级别
curl -X POST http://remote-server:5678/admin/log-level \
  -d '{"level": "debug"}'

# 4. 收集诊断数据
# 创建诊断脚本
#!/bin/bash
# collect-diagnostics.sh
DATE=$(date +%Y%m%d_%H%M%S)
OUTPUT="diagnostics_$DATE"
mkdir -p $OUTPUT

# 收集日志
cp /app/logs/app.log $OUTPUT/

# 收集pprof数据
curl -s http://localhost:6060/debug/pprof/profile?seconds=30 > $OUTPUT/cpu.pprof
curl -s http://localhost:6060/debug/pprof/heap > $OUTPUT/heap.pprof
curl -s http://localhost:6060/debug/pprof/goroutine > $OUTPUT/goroutine.pprof

# 收集系统信息
ps aux > $OUTPUT/processes.txt
df -h > $OUTPUT/disk.txt
free -m > $OUTPUT/memory.txt

tar czf $OUTPUT.tar.gz $OUTPUT
echo "Diagnostics collected: $OUTPUT.tar.gz"
```

### 5.4 生产环境排查

```go
// 日志聚合配置（Loki示例）
// 将日志发送到中央日志系统

import (
    "github.com/grafana/loki-client-go/loki"
    "github.com/prometheus/common/model"
)

func NewLokiLogger() (*loki.Client, error) {
    config := loki.Config{
        URL:        "http://loki:3100/api/prom/push",
        BatchSize:  100,
        BatchWait:  1 * time.Second,
    }
    
    client, err := loki.New(config)
    if err != nil {
        return nil, err
    }
    
    return client, nil
}

// 结构化日志方便查询
log.Infow("Drama created",
    "drama_id", drama.ID,
    "user_id", userID,
    "duration_ms", duration,
)
// Loki查询：{app="huobao-drama"} |= "Drama created" | json | drama_id="123"
```

### 5.5 故障排查检查清单

```markdown
## 问题排查清单

### 基本信息
- [ ] 问题首次发生时间
- [ ] 问题发生频率（偶发/持续）
- [ ] 影响用户数
- [ ] 错误现象描述
- [ ] 是否能稳定复现

### 日志检查
- [ ] 应用错误日志
- [ ] 系统日志（dmesg, syslog）
- [ ] 数据库日志
- [ ] Nginx/代理日志
- [ ] 相关时间段的完整日志

### 系统检查
- [ ] CPU使用率
- [ ] 内存使用率
- [ ] 磁盘空间
- [ ] 磁盘I/O
- [ ] 网络连接数
- [ ] Goroutine数量

### 数据库检查
- [ ] 连接池状态
- [ ] 慢查询日志
- [ ] 死锁检测
- [ ] 表锁定情况
- [ ] 索引使用情况

### 外部依赖
- [ ] AI服务状态
- [ ] 存储服务状态
- [ ] 网络连通性
- [ ] DNS解析

### 近期变更
- [ ] 代码变更（git log）
- [ ] 配置变更
- [ ] 数据变更
- [ ] 依赖更新
- [ ] 部署时间

### 诊断工具使用
- [ ] pprof收集
- [ ] 线程/Goroutine dump
- [ ] 内存分析
- [ ] 网络抓包

### 临时缓解
- [ ] 重启服务
- [ ] 限流降级
- [ ] 切换备用服务
- [ ] 回滚版本

### 后续行动
- [ ] 根本原因分析
- [ ] 修复方案
- [ ] 测试验证
- [ ] 监控增强
- [ ] 复盘文档
```
