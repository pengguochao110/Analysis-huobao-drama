# 06-测试指南

## 1. 测试策略概述

### 1.1 测试金字塔

火宝短剧项目遵循测试金字塔原则，测试分层如下：

```
        /\
       /  \      E2E测试（端到端）
      /----\        覆盖完整用户流程
     /      \     比例：10%
    /--------\
   /          \   集成测试（API/服务）
  /------------\    测试组件间交互
 /              \   比例：30%
/----------------\
     单元测试      单元测试（函数/组件）
                    测试最小可测试单元
                    比例：60%
```

**测试目标**：核心业务模块（Service层、关键Handler、核心组件）代码覆盖率 > 80%

### 1.2 测试目录结构

```
huobao-drama/
├── application/services/          # 业务逻辑层
│   ├── drama_service.go
│   └── drama_service_test.go      # 单元测试（同目录）
├── api/handlers/                  # API处理层
│   ├── drama.go
│   └── drama_test.go              # Handler测试
├── internal/test/                 # 测试工具包
│   ├── fixtures/                  # 测试数据
│   │   ├── dramas.yaml
│   │   └── episodes.yaml
│   └── helpers/                   # 测试辅助函数
│       ├── database.go
│       └── http.go
├── web/                           # 前端项目
│   ├── src/
│   │   └── views/
│   │       └── drama/
│   │           ├── DramaList.vue
│   │           └── __tests__/     # 组件测试目录
│   │               └── DramaList.spec.ts
│   ├── tests/                     # 测试配置和工具
│   │   ├── unit/                  # 单元测试
│   │   ├── integration/           # 集成测试
│   │   └── e2e/                   # E2E测试
│   └── vitest.config.ts           # Vitest配置
└── tests/                         # 后端测试目录（可选）
    ├── integration/
    └── e2e/
```

## 2. Go后端测试

### 2.1 单元测试基础

#### 表格驱动测试模式

Go语言推荐表格驱动测试（Table-Driven Tests），一个测试函数覆盖多个测试用例：

```go
// application/services/drama_service_test.go
package services

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestDramaService_CreateDrama(t *testing.T) {
    // 定义测试用例表格
    tests := []struct {
        name        string
        req         CreateDramaRequest
        wantErr     bool
        expectedErr string
    }{
        {
            name: "正常创建",
            req: CreateDramaRequest{
                Title:       "测试短剧",
                Description: "这是一个测试短剧",
                Genre:       "喜剧",
            },
            wantErr: false,
        },
        {
            name: "标题为空",
            req: CreateDramaRequest{
                Title: "",
            },
            wantErr:     true,
            expectedErr: "标题不能为空",
        },
        {
            name: "标题过长",
            req: CreateDramaRequest{
                Title: string(make([]byte, 101)), // 101个字符
            },
            wantErr:     true,
            expectedErr: "标题长度超过限制",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 准备测试环境
            db := setupTestDB(t)
            service := NewDramaService(db, nil, nil)

            // 执行测试
            drama, err := service.CreateDrama(&tt.req)

            // 验证结果
            if tt.wantErr {
                assert.Error(t, err)
                if tt.expectedErr != "" {
                    assert.Contains(t, err.Error(), tt.expectedErr)
                }
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, drama)
                assert.Equal(t, tt.req.Title, drama.Title)
                assert.Equal(t, "draft", drama.Status)
            }
        })
    }
}
```

#### testify/assert 使用

项目使用 `stretchr/testify` 提供丰富的断言函数：

```go
import "github.com/stretchr/testify/assert"

// 基本断言
assert.Equal(t, expected, actual)           // 相等
assert.NotEqual(t, unexpected, actual)      // 不相等
assert.Nil(t, object)                       // nil
assert.NotNil(t, object)                    // 非nil
assert.True(t, condition)                   // 真
assert.False(t, condition)                  // 假
assert.Empty(t, collection)                 // 空
assert.NotEmpty(t, collection)              // 非空
assert.Contains(t, collection, item)        // 包含

// 错误断言
assert.Error(t, err)                        // 有错误
assert.NoError(t, err)                      // 无错误
assert.EqualError(t, err, "expected error") // 错误消息匹配

// 类型断言
assert.IsType(t, &models.Drama{}, drama)
assert.Implements(t, (*Service)(nil), service)
```

### 2.2 Mock测试

#### gomock 安装

```bash
# 安装gomock工具
go install github.com/golang/mock/mockgen@latest

# 生成mock代码
mockgen -source=application/services/drama_service.go \
    -destination=application/services/mocks/drama_service_mock.go \
    -package=mocks
```

#### 接口Mock示例

```go
// 为AI服务接口生成Mock
type AIService interface {
    GenerateScript(ctx context.Context, prompt string) (string, error)
    GenerateImage(ctx context.Context, prompt string) (string, error)
}

// 测试中使用Mock
func TestScriptGenerationService_Generate(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    // 创建Mock对象
    mockAI := mocks.NewMockAIService(ctrl)
    
    // 设置期望
    mockAI.EXPECT().
        GenerateScript(gomock.Any(), gomock.Any()).
        Return("生成的剧本内容", nil).
        Times(1)

    // 使用Mock创建服务
    service := NewScriptGenerationService(mockAI)
    
    // 执行测试
    script, err := service.Generate(context.Background(), "提示词")
    
    // 验证
    assert.NoError(t, err)
    assert.Equal(t, "生成的剧本内容", script)
}
```

### 2.3 集成测试

#### 测试数据库设置

```go
// internal/test/helpers/database.go
package helpers

import (
    "testing"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
    "github.com/drama-generator/backend/domain/models"
)

// SetupTestDB 创建内存测试数据库
func SetupTestDB(t *testing.T) *gorm.DB {
    db, err := gorm.Open(sqlite.Open("file::memory:?cache=shared"), &gorm.Config{})
    if err != nil {
        t.Fatalf("failed to connect test database: %v", err)
    }

    // 自动迁移表结构
    err = db.AutoMigrate(
        &models.Drama{},
        &models.Episode{},
        &models.Character{},
        &models.Scene{},
        &models.Storyboard{},
    )
    if err != nil {
        t.Fatalf("failed to migrate test database: %v", err)
    }

    return db
}

// LoadFixtures 加载测试数据
func LoadFixtures(t *testing.T, db *gorm.DB, fixtures ...interface{}) {
    for _, fixture := range fixtures {
        if err := db.Create(fixture).Error; err != nil {
            t.Fatalf("failed to load fixture: %v", err)
        }
    }
}
```

#### HTTP测试（httptest）

```go
// api/handlers/drama_test.go
package handlers

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
)

func TestDramaHandler_CreateDrama(t *testing.T) {
    // 设置Gin测试模式
    gin.SetMode(gin.TestMode)
    
    // 准备测试数据库
    db := helpers.SetupTestDB(t)
    
    // 创建handler
    handler := NewDramaHandler(db, nil, nil, nil)
    
    // 创建Gin路由
    router := gin.New()
    router.POST("/api/v1/dramas", handler.CreateDrama)
    
    // 准备请求
    reqBody := `{"title": "测试短剧", "description": "描述"}`
    req := httptest.NewRequest(http.MethodPost, "/api/v1/dramas", 
        bytes.NewBufferString(reqBody))
    req.Header.Set("Content-Type", "application/json")
    
    // 执行请求
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    // 验证响应
    assert.Equal(t, http.StatusCreated, w.Code)
    
    var response map[string]interface{}
    err := json.Unmarshal(w.Body.Bytes(), &response)
    assert.NoError(t, err)
    assert.True(t, response["success"].(bool))
    assert.NotNil(t, response["data"])
}

func TestDramaHandler_ListDramas(t *testing.T) {
    gin.SetMode(gin.TestMode)
    db := helpers.SetupTestDB(t)
    
    // 加载测试数据
    helpers.LoadFixtures(t, db, 
        &models.Drama{Title: "短剧1", Status: "draft"},
        &models.Drama{Title: "短剧2", Status: "completed"},
    )
    
    handler := NewDramaHandler(db, nil, nil, nil)
    router := gin.New()
    router.GET("/api/v1/dramas", handler.ListDramas)
    
    // 测试分页
    req := httptest.NewRequest(http.MethodGet, 
        "/api/v1/dramas?page=1&page_size=10", nil)
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusOK, w.Code)
    
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    
    data := response["data"].(map[string]interface{})
    items := data["items"].([]interface{})
    assert.Len(t, items, 2)
}
```

### 2.4 测试数据管理

#### Fixtures模式

```go
// internal/test/fixtures/dramas.go
package fixtures

import "github.com/drama-generator/backend/domain/models"

var TestDrama = models.Drama{
    Title:       "测试短剧",
    Description: strPtr("这是一个测试短剧"),
    Genre:       strPtr("喜剧"),
    Status:      "draft",
    TotalEpisodes: 3,
}

var TestEpisode = models.Episode{
    EpisodeNum: 1,
    Title:      "第一集",
    Status:     "draft",
}

func strPtr(s string) *string {
    return &s
}
```

#### 工厂模式（gofactory风格）

```go
// internal/test/factories/drama_factory.go
package factories

import (
    "fmt"
    "gorm.io/gorm"
    "github.com/drama-generator/backend/domain/models"
)

// DramaFactory 短剧工厂
type DramaFactory struct {
    db *gorm.DB
}

func NewDramaFactory(db *gorm.DB) *DramaFactory {
    return &DramaFactory{db: db}
}

// Create 创建短剧
func (f *DramaFactory) Create(opts ...DramaOption) (*models.Drama, error) {
    drama := &models.Drama{
        Title:    "默认短剧标题",
        Status:   "draft",
    }
    
    // 应用选项
    for _, opt := range opts {
        opt(drama)
    }
    
    if err := f.db.Create(drama).Error; err != nil {
        return nil, err
    }
    return drama, nil
}

// CreateMany 批量创建
func (f *DramaFactory) CreateMany(count int) ([]*models.Drama, error) {
    dramas := make([]*models.Drama, 0, count)
    for i := 0; i < count; i++ {
        drama, err := f.Create(WithTitle(fmt.Sprintf("短剧%d", i+1)))
        if err != nil {
            return nil, err
        }
        dramas = append(dramas, drama)
    }
    return dramas, nil
}

// DramaOption 功能选项类型
type DramaOption func(*models.Drama)

func WithTitle(title string) DramaOption {
    return func(d *models.Drama) {
        d.Title = title
    }
}

func WithStatus(status string) DramaOption {
    return func(d *models.Drama) {
        d.Status = status
    }
}

func WithEpisodes(count int) DramaOption {
    return func(d *models.Drama) {
        d.TotalEpisodes = count
    }
}

// 使用示例
func TestWithFactory(t *testing.T) {
    db := helpers.SetupTestDB(t)
    factory := NewDramaFactory(db)
    
    // 创建带选项的短剧
    drama, err := factory.Create(
        WithTitle("我的短剧"),
        WithStatus("planning"),
        WithEpisodes(5),
    )
    assert.NoError(t, err)
    assert.Equal(t, "我的短剧", drama.Title)
}
```

### 2.5 运行测试

```bash
# 运行所有测试
go test ./...

# 运行特定包测试
go test ./application/services/...

# 运行特定测试函数
go test -run TestDramaService_CreateDrama ./application/services/

# 运行测试并显示详情
go test -v ./...

# 生成覆盖率报告
go test -cover ./...
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html

# 只测试修改的文件（配合git）
go test -short ./...
```

### 2.6 完整示例：DramaService测试

```go
// application/services/drama_service_test.go
package services

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/suite"
    "github.com/drama-generator/backend/internal/test/helpers"
    "github.com/drama-generator/backend/internal/test/factories"
    "github.com/drama-generator/backend/pkg/config"
    "github.com/drama-generator/backend/pkg/logger"
)

// DramaServiceTestSuite 测试套件
type DramaServiceTestSuite struct {
    suite.Suite
    db      *gorm.DB
    service *DramaService
    factory *factories.DramaFactory
}

// SetupSuite 套件级设置
func (s *DramaServiceTestSuite) SetupSuite() {
    s.db = helpers.SetupTestDB(s.T())
    cfg := &config.Config{Storage: config.StorageConfig{BaseURL: "http://localhost"}}
    log := logger.NewLogger(true)
    s.service = NewDramaService(s.db, cfg, log)
    s.factory = factories.NewDramaFactory(s.db)
}

// SetupTest 测试级设置
func (s *DramaServiceTestSuite) SetupTest() {
    // 清空测试数据
    s.db.Exec("DELETE FROM dramas")
}

func (s *DramaServiceTestSuite) TestCreateDrama() {
    req := &CreateDramaRequest{
        Title:       "新短剧",
        Description: "描述信息",
        Genre:       "动作",
    }
    
    drama, err := s.service.CreateDrama(req)
    
    s.NoError(err)
    s.NotNil(drama)
    s.Equal("新短剧", drama.Title)
    s.Equal("draft", drama.Status)
}

func (s *DramaServiceTestSuite) TestGetDrama() {
    // 先创建测试数据
    drama, _ := s.factory.Create(factories.WithTitle("查询测试"))
    
    // 测试查询
    result, err := s.service.GetDrama(fmt.Sprintf("%d", drama.ID))
    
    s.NoError(err)
    s.Equal(drama.Title, result.Title)
}

func (s *DramaServiceTestSuite) TestListDramas() {
    // 创建测试数据
    s.factory.CreateMany(5)
    
    query := &DramaListQuery{
        Page:     1,
        PageSize: 10,
    }
    
    dramas, total, err := s.service.ListDramas(query)
    
    s.NoError(err)
    s.Equal(int64(5), total)
    s.Len(dramas, 5)
}

func (s *DramaServiceTestSuite) TestDeleteDrama() {
    drama, _ := s.factory.Create()
    
    err := s.service.DeleteDrama(fmt.Sprintf("%d", drama.ID))
    
    s.NoError(err)
    
    // 验证已删除
    var count int64
    s.db.Model(&models.Drama{}).Where("id = ?", drama.ID).Count(&count)
    s.Equal(int64(0), count)
}

// 运行测试套件
func TestDramaServiceTestSuite(t *testing.T) {
    suite.Run(t, new(DramaServiceTestSuite))
}
```

## 3. Vue前端测试

### 3.1 Vitest配置

```typescript
// web/vitest.config.ts
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  test: {
    globals: true,
    environment: 'happy-dom', // 或 'jsdom'
    include: ['src/**/*.spec.ts', 'src/**/*.test.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/**/*.d.ts',
        'src/main.ts',
      ],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 70,
        statements: 80,
      },
    },
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
    },
  },
})
```

### 3.2 组件测试

```typescript
// web/src/views/drama/__tests__/DramaList.spec.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount, flushPromises } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import DramaList from '../DramaList.vue'
import { dramaAPI } from '@/api/drama'

// Mock API
vi.mock('@/api/drama', () => ({
  dramaAPI: {
    list: vi.fn(),
    delete: vi.fn(),
    get: vi.fn(),
    update: vi.fn(),
  },
}))

describe('DramaList', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.clearAllMocks()
  })

  it('应该正确渲染短剧列表', async () => {
    // Mock API返回数据
    const mockDramas = [
      { id: 1, title: '短剧1', description: '描述1', updated_at: '2024-01-01' },
      { id: 2, title: '短剧2', description: '描述2', updated_at: '2024-01-02' },
    ]
    
    vi.mocked(dramaAPI.list).mockResolvedValue({
      items: mockDramas,
      pagination: { total: 2, page: 1, page_size: 12, total_pages: 1 },
    })

    // 挂载组件
    const wrapper = mount(DramaList)
    
    // 等待异步操作完成
    await flushPromises()
    
    // 验证渲染
    expect(wrapper.findAll('.project-card')).toHaveLength(2)
    expect(wrapper.text()).toContain('短剧1')
    expect(wrapper.text()).toContain('短剧2')
  })

  it('应该显示空状态当没有短剧', async () => {
    vi.mocked(dramaAPI.list).mockResolvedValue({
      items: [],
      pagination: { total: 0, page: 1, page_size: 12, total_pages: 0 },
    })

    const wrapper = mount(DramaList)
    await flushPromises()
    
    expect(wrapper.find('.empty-state').exists()).toBe(true)
    expect(wrapper.text()).toContain('暂无短剧')
  })

  it('应该正确处理删除操作', async () => {
    vi.mocked(dramaAPI.list).mockResolvedValue({
      items: [{ id: 1, title: '测试短剧', description: '', updated_at: '' }],
      pagination: { total: 1, page: 1, page_size: 12, total_pages: 1 },
    })
    vi.mocked(dramaAPI.delete).mockResolvedValue(undefined)

    const wrapper = mount(DramaList)
    await flushPromises()
    
    // 点击删除按钮
    await wrapper.find('.action-button.danger').trigger('click')
    
    // 确认删除API被调用
    expect(dramaAPI.delete).toHaveBeenCalledWith('1')
  })
})
```

### 3.3 Store测试（Pinia）

```typescript
// web/src/stores/__tests__/episode.spec.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useEpisodeStore } from '../episode'
import { dramaAPI } from '@/api/drama'

vi.mock('@/api/drama')

describe('Episode Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.clearAllMocks()
  })

  it('应该获取缓存的章节', async () => {
    const mockDrama = {
      id: 1,
      episodes: [
        { id: 101, episode_number: 1, title: '第一集' },
      ],
    }
    
    vi.mocked(dramaAPI.get).mockResolvedValue(mockDrama)

    const store = useEpisodeStore()
    const cached = store.getCacheByEpisodeId('1-1')
    
    // 初始状态
    expect(cached.loading).toBe(true)
    
    // 等待数据加载
    await vi.waitFor(() => !cached.loading)
    
    expect(cached.value.title).toBe('第一集')
    expect(dramaAPI.get).toHaveBeenCalledWith('1')
  })

  it('应该缓存数据避免重复请求', async () => {
    vi.mocked(dramaAPI.get).mockResolvedValue({
      id: 1,
      episodes: [{ id: 101, episode_number: 1, title: '第一集' }],
    })

    const store = useEpisodeStore()
    
    // 第一次获取
    const cached1 = store.getCacheByEpisodeId('1-1')
    await vi.waitFor(() => !cached1.loading)
    
    // 第二次获取同一章节
    const cached2 = store.getCacheByEpisodeId('1-1')
    
    // API应该只被调用一次
    expect(dramaAPI.get).toHaveBeenCalledTimes(1)
    expect(cached1).toBe(cached2) // 同一对象引用
  })

  it('应该正确刷新数据', async () => {
    vi.mocked(dramaAPI.get)
      .mockResolvedValueOnce({ id: 1, episodes: [{ id: 101, title: '旧标题' }] })
      .mockResolvedValueOnce({ id: 1, episodes: [{ id: 101, title: '新标题' }] })

    const store = useEpisodeStore()
    const cached = store.getCacheByEpisodeId('1-1')
    
    await vi.waitFor(() => !cached.loading)
    expect(cached.value.title).toBe('旧标题')
    
    // 强制刷新
    await cached.refresh()
    
    expect(cached.value.title).toBe('新标题')
    expect(dramaAPI.get).toHaveBeenCalledTimes(2)
  })
})
```

### 3.4 API Mock（MSW）

```typescript
// web/tests/mocks/handlers.ts
import { http, HttpResponse } from 'msw'

export const handlers = [
  // 短剧列表
  http.get('/api/v1/dramas', ({ request }) => {
    const url = new URL(request.url)
    const page = url.searchParams.get('page') || '1'
    
    return HttpResponse.json({
      success: true,
      data: {
        items: [
          { id: 1, title: 'Mock短剧1', status: 'draft' },
          { id: 2, title: 'Mock短剧2', status: 'completed' },
        ],
        pagination: {
          page: parseInt(page),
          page_size: 12,
          total: 2,
          total_pages: 1,
        },
      },
    })
  }),

  // 创建短剧
  http.post('/api/v1/dramas', async ({ request }) => {
    const body = await request.json()
    
    return HttpResponse.json({
      success: true,
      data: {
        id: 999,
        title: body.title,
        status: 'draft',
        created_at: new Date().toISOString(),
      },
    }, { status: 201 })
  }),

  // 错误场景
  http.delete('/api/v1/dramas/:id', ({ params }) => {
    if (params.id === '999') {
      return HttpResponse.json({
        success: false,
        error: { message: '短剧不存在' },
      }, { status: 404 })
    }
    
    return HttpResponse.json({
      success: true,
      data: { message: '删除成功' },
    })
  }),
]

// web/tests/setup.ts
import { setupServer } from 'msw/node'
import { handlers } from './mocks/handlers'

export const server = setupServer(...handlers)

beforeAll(() => server.listen({ onUnhandledRequest: 'error' }))
afterEach(() => server.resetHandlers())
afterAll(() => server.close())
```

### 3.5 运行前端测试

```bash
# 进入前端目录
cd web

# 运行测试
pnpm test

# 运行测试并监视
pnpm test --watch

# 生成覆盖率报告
pnpm test --coverage

# 运行特定测试文件
pnpm test DramaList.spec.ts

# 运行UI模式
pnpm test --ui
```

## 4. E2E端到端测试

### 4.1 Playwright配置

```typescript
// web/playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:5678',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
  ],
  webServer: {
    command: 'cd .. && go run main.go',
    url: 'http://localhost:5678',
    reuseExistingServer: !process.env.CI,
  },
})
```

### 4.2 场景测试

```typescript
// web/tests/e2e/drama-workflow.spec.ts
import { test, expect } from '@playwright/test'

test.describe('短剧完整工作流', () => {
  test('创建短剧→生成内容→导出视频', async ({ page }) => {
    // 1. 访问首页
    await page.goto('/')
    await expect(page.locator('h1')).toContainText('短剧')

    // 2. 创建新短剧
    await page.click('text=创建新短剧')
    await page.fill('[placeholder="请输入短剧标题"]', 'E2E测试短剧')
    await page.fill('[placeholder="请输入描述"]', '这是一个E2E测试')
    await page.click('text=确定')

    // 3. 验证创建成功并跳转到详情页
    await expect(page).toHaveURL(/\/dramas\/\d+/)
    await expect(page.locator('.drama-title')).toContainText('E2E测试短剧')

    // 4. 添加角色
    await page.click('text=角色管理')
    await page.click('text=添加角色')
    await page.fill('[name="name"]', '主角A')
    await page.fill('[name="description"]', '主角A的描述')
    await page.click('text=保存')
    
    // 验证角色已添加
    await expect(page.locator('.character-card')).toContainText('主角A')

    // 5. 创建章节
    await page.click('text=章节管理')
    await page.click('text=新建章节')
    await page.fill('[name="title"]', '第一集')
    await page.click('text=创建')

    // 6. 编写剧本
    await page.click('text=编写剧本')
    await page.fill('.script-editor', '这是一个测试剧本内容')
    await page.click('text=保存剧本')
    await expect(page.locator('.el-message--success')).toBeVisible()

    // 7. 生成分镜
    await page.click('text=分镜生成')
    await page.click('text=一键生成分镜')
    
    // 等待生成完成（轮询状态）
    await page.waitForSelector('.storyboard-card', { timeout: 60000 })

    // 8. 生成图片
    await page.click('text=图片生成')
    await page.click('.generate-all-btn')
    
    // 等待图片生成
    await page.waitForSelector('.generated-image', { timeout: 120000 })

    // 9. 生成视频
    await page.click('text=视频生成')
    await page.click('text=生成视频')
    
    // 等待视频生成任务完成
    await page.waitForSelector('.video-player', { timeout: 300000 })

    // 10. 下载视频
    const [download] = await Promise.all([
      page.waitForEvent('download'),
      page.click('text=下载视频'),
    ])
    
    expect(download.suggestedFilename()).toMatch(/\.mp4$/)
  })
})

test.describe('错误场景', () => {
  test('创建短剧时验证必填字段', async ({ page }) => {
    await page.goto('/')
    await page.click('text=创建新短剧')
    await page.click('text=确定')
    
    // 验证错误提示
    await expect(page.locator('.el-form-item__error')).toContainText('请输入标题')
  })

  test('删除短剧需要确认', async ({ page }) => {
    // 先创建一个短剧
    await page.goto('/dramas/create')
    await page.fill('[name="title"]', '待删除短剧')
    await page.click('text=创建')
    
    // 尝试删除
    await page.click('text=删除')
    await expect(page.locator('.el-message-box')).toBeVisible()
    
    // 取消删除
    await page.click('text=取消')
    await expect(page.locator('.drama-title')).toContainText('待删除短剧')
  })
})
```

### 4.3 数据准备与清理

```typescript
// web/tests/e2e/fixtures/cleanup.ts
import { test as base } from '@playwright/test'
import { APIRequestContext } from '@playwright/test'

// 扩展test fixtures
export const test = base.extend<{
  cleanupDramas: () => Promise<void>
}>({
  cleanupDramas: async ({ request }, use) => {
    const createdDramaIds: number[] = []
    
    // 提供注册函数
    const registerDrama = (id: number) => createdDramaIds.push(id)
    
    // 在测试中可用
    await use(async () => {
      // 测试结束后清理
      for (const id of createdDramaIds) {
        await request.delete(`/api/v1/dramas/${id}`)
      }
    })
  },
})

// 使用示例
import { test } from './fixtures/cleanup'

test('创建和清理', async ({ page, request, cleanupDramas }) => {
  // 创建短剧
  const response = await request.post('/api/v1/dramas', {
    data: { title: '临时短剧' },
  })
  const drama = await response.json()
  
  // 注册以便清理
  cleanupDramas()
  
  // 继续测试...
})
```

### 4.4 CI/CD集成

```yaml
# .github/workflows/e2e.yml
name: E2E Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: web/pnpm-lock.yaml
      
      - name: Install dependencies
        run: |
          cd web
          pnpm install
          npx playwright install --with-deps
      
      - name: Build frontend
        run: |
          cd web
          pnpm build
      
      - name: Run backend
        run: |
          go run main.go &
          sleep 5
      
      - name: Run E2E tests
        run: |
          cd web
          pnpm test:e2e
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: web/playwright-report/
```

## 5. 测试最佳实践

### 5.1 测试命名规范

```go
// Go测试命名
// 格式: Test{被测对象}_{场景}_{预期结果}

func TestDramaService_CreateDrama_Success()           // 成功场景
func TestDramaService_CreateDrama_ValidationError()   // 验证错误
func TestDramaService_CreateDrama_DuplicateTitle()    // 重复标题
func TestDramaService_GetDrama_NotFound()             // 未找到
func TestDramaHandler_ListDramas_Pagination()         // 分页测试
func TestDramaHandler_ListDramas_FilterByStatus()     // 过滤测试
```

```typescript
// Vue测试命名
// 格式: should {预期行为} when {条件}

describe('DramaList', () => {
  it('should render drama list when data loaded')
  it('should show empty state when no dramas')
  it('should handle delete when confirm clicked')
  it('should display error message when API fails')
  it('should navigate to detail when card clicked')
})
```

### 5.2 Given-When-Then模式

```go
func TestDramaService_UpdateDrama(t *testing.T) {
    // Given: 前置条件
    db := setupTestDB(t)
    factory := factories.NewDramaFactory(db)
    drama, _ := factory.Create(factories.WithTitle("原标题"))
    service := NewDramaService(db, nil, nil)
    
    // When: 执行操作
    updated, err := service.UpdateDrama(fmt.Sprintf("%d", drama.ID), &UpdateDramaRequest{
        Title: "新标题",
    })
    
    // Then: 验证结果
    assert.NoError(t, err)
    assert.Equal(t, "新标题", updated.Title)
    
    // 验证数据库状态
    var dbDrama models.Drama
    db.First(&dbDrama, drama.ID)
    assert.Equal(t, "新标题", dbDrama.Title)
}
```

### 5.3 测试隔离性

```go
// 每个测试独立，不依赖执行顺序
func TestSuite(t *testing.T) {
    // 错误：测试间共享数据
    db := setupDB()  // 不要这样做！
    
    t.Run("test1", func(t *testing.T) {
        // 修改db...
    })
    
    t.Run("test2", func(t *testing.T) {
        // 依赖test1的状态 - 错误！
    })
}

// 正确：每个测试独立设置
func TestCase1(t *testing.T) {
    db := setupTestDB(t)  // 每个测试独立数据库
    // 测试...
}

func TestCase2(t *testing.T) {
    db := setupTestDB(t)  // 新的独立数据库
    // 测试...
}
```

### 5.4 并行测试配置

```go
// Go并行测试
func TestParallel(t *testing.T) {
    t.Parallel()  // 标记可并行
    
    tests := []struct{ name string }{
        {name: "case1"},
        {name: "case2"},
    }
    
    for _, tt := range tests {
        tt := tt  // 捕获循环变量
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()  // 子测试也并行
            // 测试逻辑...
        })
    }
}
```

```typescript
// Vitest并行配置
// vitest.config.ts
export default defineConfig({
  test: {
    pool: 'threads',      // 使用线程池
    poolOptions: {
      threads: {
        singleThread: false,
        maxThreads: 4,
      },
    },
  },
})
```

### 5.5 测试检查清单

在提交代码前，确保：

- [ ] 所有测试通过 (`go test ./...` / `pnpm test`)
- [ ] 代码覆盖率 > 80% (`go test -cover` / `pnpm test --coverage`)
- [ ] 新增代码有对应的测试
- [ ] 测试命名清晰表达意图
- [ ] 测试之间相互独立
- [ ] 使用表格驱动测试覆盖边界情况
- [ ] Mock外部依赖（数据库、API、文件系统）
- [ ] 测试数据使用工厂模式或Fixtures
- [ ] 清理测试产生的临时数据
