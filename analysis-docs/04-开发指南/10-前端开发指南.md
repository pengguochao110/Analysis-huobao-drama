# 10-前端开发指南

## 1. 组件开发规范

### 1.1 单文件组件结构

Vue3单文件组件（SFC）标准结构：

```vue
<!-- 标准结构示例 -->
<template>
  <!-- 模板内容 -->
</template>

<script setup lang="ts">
// 组合式API代码
</script>

<style scoped>
/* 组件样式 */
</style>
```

火宝短剧项目完整组件示例：

```vue
<!-- DramaCard.vue -->
<template>
  <div class="drama-card" :class="{ 'is-featured': featured }" @click="handleClick">
    <!-- 缩略图区域 -->
    <div class="card-thumbnail">
      <img :src="thumbnail || defaultThumbnail" :alt="title" />
      <div v-if="badge" class="card-badge">{{ badge }}</div>
    </div>
    
    <!-- 内容区域 -->
    <div class="card-content">
      <h3 class="card-title">{{ title }}</h3>
      <p class="card-description">{{ truncatedDescription }}</p>
      <div class="card-meta">
        <span class="meta-item">
          <el-icon><Calendar /></el-icon>
          {{ formatDate(updatedAt) }}
        </span>
        <span class="meta-item">
          <el-icon><VideoPlay /></el-icon>
          {{ episodeCount }}集
        </span>
      </div>
    </div>
    
    <!-- 操作区域（插槽） -->
    <div class="card-actions" @click.stop>
      <slot name="actions">
        <el-button type="primary" size="small" @click="handleEdit">
          编辑
        </el-button>
      </slot>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { Calendar, VideoPlay } from '@element-plus/icons-vue'
import dayjs from 'dayjs'

// ==================== Props定义 ====================
interface Props {
  /** 短剧ID */
  id: string | number
  /** 标题 */
  title: string
  /** 描述 */
  description?: string
  /** 缩略图URL */
  thumbnail?: string
  /** 更新时间 */
  updatedAt: string
  /** 集数 */
  episodeCount?: number
  /** 是否推荐 */
  featured?: boolean
  /** 标签 */
  badge?: string
}

const props = withDefaults(defineProps<Props>(), {
  description: '',
  thumbnail: '',
  episodeCount: 0,
  featured: false,
  badge: ''
})

// ==================== Emits定义 ====================
interface Emits {
  /** 点击卡片 */
  (e: 'click', id: string | number): void
  /** 点击编辑 */
  (e: 'edit', id: string | number): void
  /** 点击删除 */
  (e: 'delete', id: string | number): void
}

const emit = defineEmits<Emits>()

// ==================== 计算属性 ====================
const defaultThumbnail = '/images/default-drama.png'

const truncatedDescription = computed(() => {
  if (!props.description) return '暂无描述'
  return props.description.length > 100 
    ? props.description.slice(0, 100) + '...' 
    : props.description
})

// ==================== 方法 ====================
const formatDate = (date: string) => {
  return dayjs(date).format('YYYY-MM-DD')
}

const handleClick = () => {
  emit('click', props.id)
}

const handleEdit = () => {
  emit('edit', props.id)
}
</script>

<style scoped>
.drama-card {
  display: flex;
  flex-direction: column;
  background: var(--bg-card);
  border-radius: var(--radius-lg);
  overflow: hidden;
  transition: all 0.3s ease;
  cursor: pointer;
}

.drama-card:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-lg);
}

.drama-card.is-featured {
  border: 2px solid var(--accent);
}

.card-thumbnail {
  position: relative;
  aspect-ratio: 16 / 9;
  overflow: hidden;
}

.card-thumbnail img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.card-badge {
  position: absolute;
  top: 8px;
  right: 8px;
  padding: 4px 8px;
  background: var(--accent);
  color: white;
  font-size: 12px;
  border-radius: var(--radius-sm);
}

.card-content {
  flex: 1;
  padding: 16px;
}

.card-title {
  margin: 0 0 8px;
  font-size: 16px;
  font-weight: 600;
  color: var(--text-primary);
  line-height: 1.4;
}

.card-description {
  margin: 0 0 12px;
  font-size: 14px;
  color: var(--text-secondary);
  line-height: 1.5;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.card-meta {
  display: flex;
  gap: 16px;
  font-size: 12px;
  color: var(--text-muted);
}

.meta-item {
  display: flex;
  align-items: center;
  gap: 4px;
}

.card-actions {
  padding: 12px 16px;
  border-top: 1px solid var(--border-primary);
}
</style>
```

### 1.2 组件命名规范

```typescript
// 文件名：PascalCase
// ✅ DramaList.vue, CreateDramaDialog.vue, VideoPlayer.vue
// ❌ drama-list.vue, create-drama-dialog.vue

// 组件名：语义化、自解释
// ✅ DramaCard - 明确是短剧卡片
// ✅ EmptyState - 空状态组件
// ❌ Card - 太泛
// ❌ List - 太泛

// 引用时保持一致
import DramaCard from '@/components/common/DramaCard.vue'
import EmptyState from '@/components/common/EmptyState.vue'

// 避免与HTML元素冲突
// ✅ AppHeader, BaseButton, PageContainer
// ❌ Header, Button, Section
```

### 1.3 Props定义最佳实践

```typescript
// 使用interface定义Props类型
interface Props {
  // 必填项
  id: string
  title: string
  
  // 可选项（带默认值）
  description?: string
  status?: 'draft' | 'published' | 'archived'
  
  // 复杂类型
  metadata?: Record<string, any>
  tags?: string[]
  
  // 回调函数
  onUpdate?: (id: string, data: Partial<Drama>) => void
}

// 使用withDefaults提供默认值
const props = withDefaults(defineProps<Props>(), {
  description: '',
  status: 'draft',
  metadata: () => ({}),
  tags: () => []
})

// 或使用运行时校验
const props = defineProps({
  id: {
    type: [String, Number] as PropType<string | number>,
    required: true
  },
  title: {
    type: String,
    required: true,
    validator: (value: string) => value.length > 0 && value.length <= 200
  },
  episodeCount: {
    type: Number,
    default: 0,
    validator: (value: number) => value >= 0
  }
})
```

### 1.4 Emits定义

```typescript
// 使用类型定义Emits
interface Emits {
  (e: 'update', id: string, data: UpdateData): void
  (e: 'delete', id: string): void
  (e: 'change', value: string, oldValue: string): void
}

const emit = defineEmits<Emits>()

// 或运行时定义
const emit = defineEmits({
  update: (id: string, data: UpdateData) => {
    // 返回true表示校验通过
    return typeof id === 'string' && data !== null
  },
  delete: (id: string) => typeof id === 'string'
})

// 触发事件
const handleSave = () => {
  emit('update', props.id, { title: localTitle.value })
}
```

### 1.5 插槽使用

```vue
<template>
  <!-- 默认插槽 -->
  <div class="card">
    <slot>默认内容</slot>
  </div>
  
  <!-- 具名插槽 -->
  <div class="card-header">
    <slot name="header">
      <h3>默认标题</h3>
    </slot>
  </div>
  
  <!-- 作用域插槽 -->
  <div class="card-body">
    <slot name="body" :item="currentItem" :index="currentIndex">
      {{ currentItem.name }}
    </slot>
  </div>
  
  <!-- 条件插槽 -->
  <div v-if="$slots.footer" class="card-footer">
    <slot name="footer" />
  </div>
</template>

<!-- 使用示例 -->
<DramaCard>
  <!-- 默认插槽 -->
  <p>自定义内容</p>
  
  <!-- 具名插槽 -->
  <template #header>
    <h2>自定义标题</h2>
  </template>
  
  <!-- 作用域插槽 -->
  <template #body="{ item, index }">
    <span>{{ index + 1 }}. {{ item.name }}</span>
  </template>
</DramaCard>
```

### 1.6 生命周期钩子

```typescript
import {
  onMounted,      // 挂载后
  onUnmounted,    // 卸载前
  onUpdated,      // 更新后
  onBeforeMount,  // 挂载前
  onBeforeUpdate, // 更新前
  onErrorCaptured, // 捕获错误
  watch,
  computed
} from 'vue'

// ==================== 常见模式 ====================

// 1. 数据获取
const loading = ref(false)
const data = ref<Data | null>(null)

onMounted(async () => {
  loading.value = true
  try {
    data.value = await fetchData()
  } catch (error) {
    handleError(error)
  } finally {
    loading.value = false
  }
})

// 2. 监听路由参数
import { useRoute } from 'vue-router'

const route = useRoute()

watch(
  () => route.params.id,
  (newId) => {
    if (newId) {
      loadDrama(newId as string)
    }
  },
  { immediate: true }
)

// 3. 清理副作用
const timer = ref<NodeJS.Timeout | null>(null)
const eventHandler = () => {}

onMounted(() => {
  timer.value = setInterval(() => {}, 1000)
  window.addEventListener('resize', eventHandler)
})

onUnmounted(() => {
  if (timer.value) {
    clearInterval(timer.value)
  }
  window.removeEventListener('resize', eventHandler)
})

// 4. 计算属性
const fullName = computed(() => {
  return `${firstName.value} ${lastName.value}`
})

// 5. 监听器
watch(
  () => props.id,
  (newId, oldId) => {
    if (newId !== oldId) {
      refreshData()
    }
  }
)

// 深度监听
watch(
  formData,
  (newVal) => {
    console.log('Form changed:', newVal)
  },
  { deep: true }
)
```

## 2. 状态管理（Pinia）

### 2.1 Store定义

火宝短剧项目使用Setup Store风格：

```typescript
// stores/drama.ts
import { ref, computed } from 'vue'
import { defineStore } from 'pinia'
import { dramaAPI } from '@/api/drama'
import type { Drama, DramaListQuery, CreateDramaRequest } from '@/types/drama'

export const useDramaStore = defineStore('drama', () => {
  // ==================== State ====================
  const dramas = ref<Drama[]>([])
  const currentDrama = ref<Drama | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)
  const total = ref(0)
  
  // ==================== Getters ====================
  const draftDramas = computed(() => 
    dramas.value.filter(d => d.status === 'draft')
  )
  
  const hasCurrentDrama = computed(() => currentDrama.value !== null)
  
  const dramaById = computed(() => {
    return (id: string) => dramas.value.find(d => d.id === id)
  })
  
  // ==================== Actions ====================
  async function fetchDramas(query?: DramaListQuery) {
    loading.value = true
    error.value = null
    
    try {
      const response = await dramaAPI.list(query)
      dramas.value = response.items
      total.value = response.pagination.total
      return response
    } catch (err: any) {
      error.value = err.message || '获取短剧列表失败'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  async function fetchDrama(id: string) {
    loading.value = true
    error.value = null
    
    try {
      const drama = await dramaAPI.get(id)
      currentDrama.value = drama
      return drama
    } catch (err: any) {
      error.value = err.message || '获取短剧详情失败'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  async function createDrama(data: CreateDramaRequest) {
    loading.value = true
    error.value = null
    
    try {
      const drama = await dramaAPI.create(data)
      dramas.value.unshift(drama)
      total.value++
      return drama
    } catch (err: any) {
      error.value = err.message || '创建短剧失败'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  async function updateDrama(id: string, data: Partial<Drama>) {
    loading.value = true
    
    try {
      const updated = await dramaAPI.update(id, data)
      
      // 更新本地数据
      const index = dramas.value.findIndex(d => d.id === id)
      if (index !== -1) {
        dramas.value[index] = { ...dramas.value[index], ...updated }
      }
      
      if (currentDrama.value?.id === id) {
        currentDrama.value = { ...currentDrama.value, ...updated }
      }
      
      return updated
    } catch (err: any) {
      error.value = err.message
      throw err
    } finally {
      loading.value = false
    }
  }
  
  async function deleteDrama(id: string) {
    try {
      await dramaAPI.delete(id)
      dramas.value = dramas.value.filter(d => d.id !== id)
      total.value--
      
      if (currentDrama.value?.id === id) {
        currentDrama.value = null
      }
    } catch (err: any) {
      error.value = err.message
      throw err
    }
  }
  
  function clearError() {
    error.value = null
  }
  
  function reset() {
    dramas.value = []
    currentDrama.value = null
    loading.value = false
    error.value = null
    total.value = 0
  }
  
  // ==================== 返回 ====================
  return {
    // State
    dramas,
    currentDrama,
    loading,
    error,
    total,
    // Getters
    draftDramas,
    hasCurrentDrama,
    dramaById,
    // Actions
    fetchDramas,
    fetchDrama,
    createDrama,
    updateDrama,
    deleteDrama,
    clearError,
    reset
  }
})
```

### 2.2 跨Store通信

```typescript
// stores/user.ts - 用户Store
export const useUserStore = defineStore('user', () => {
  const userInfo = ref<UserInfo | null>(null)
  const isLoggedIn = computed(() => userInfo.value !== null)
  
  return { userInfo, isLoggedIn }
})

// stores/drama.ts - 在DramaStore中使用UserStore
import { useUserStore } from './user'

export const useDramaStore = defineStore('drama', () => {
  const userStore = useUserStore()
  
  async function createDrama(data: CreateDramaRequest) {
    // 检查用户登录状态
    if (!userStore.isLoggedIn) {
      throw new Error('请先登录')
    }
    
    // 添加创建者信息
    const drama = await dramaAPI.create({
      ...data,
      creatorId: userStore.userInfo?.id
    })
    
    return drama
  }
  
  return { createDrama }
})

// 使用storeToRefs保持响应式
// components/DramaList.vue
import { storeToRefs } from 'pinia'
import { useDramaStore } from '@/stores/drama'
import { useUserStore } from '@/stores/user'

const dramaStore = useDramaStore()
const userStore = useUserStore()

// 解构保持响应式
const { dramas, loading, error } = storeToRefs(dramaStore)
const { isLoggedIn } = storeToRefs(userStore)

// 方法直接解构
const { fetchDramas, createDrama } = dramaStore
```

### 2.3 Store持久化

```typescript
// stores/drama.ts
import { defineStore } from 'pinia'
import { persist } from 'pinia-plugin-persistedstate'

export const useDramaStore = defineStore('drama', () => {
  // ... store定义
  
  return {
    dramas,
    currentDrama,
    // ...
  }
}, {
  persist: {
    key: 'huobao-drama-store',
    storage: localStorage,
    paths: ['currentDrama'],  // 只持久化特定字段
    beforeRestore: (context) => {
      console.log('Before restore:', context)
    },
    afterRestore: (context) => {
      console.log('After restore:', context)
    }
  }
})

// main.ts - 注册插件
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)

app.use(pinia)
```

## 3. API集成

### 3.1 封装请求函数

```typescript
// utils/request.ts
import type { AxiosError, AxiosInstance, AxiosRequestConfig, InternalAxiosRequestConfig } from 'axios'
import axios from 'axios'
import { ElMessage } from 'element-plus'

interface CustomAxiosInstance extends Omit<AxiosInstance, 'get' | 'post' | 'put' | 'patch' | 'delete'> {
  get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>
  post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>
  put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>
  patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>
  delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>
}

const request = axios.create({
  baseURL: '/api/v1',
  timeout: 600000,  // 10分钟，匹配后端AI生成接口
  headers: {
    'Content-Type': 'application/json'
  }
}) as CustomAxiosInstance

// 请求拦截器
request.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    // 开源版本 - 无需认证token
    // 如需添加token：
    // const token = localStorage.getItem('token')
    // if (token) {
    //   config.headers.Authorization = `Bearer ${token}`
    // }
    
    return config
  },
  (error: AxiosError) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    const res = response.data
    
    if (res.success) {
      return res.data
    } else {
      // 业务错误
      const errorMessage = res.error?.message || '请求失败'
      return Promise.reject(new Error(errorMessage))
    }
  },
  (error: AxiosError<any>) => {
    // HTTP错误处理
    const status = error.response?.status
    const message = error.response?.data?.error?.message || error.message
    
    switch (status) {
      case 400:
        ElMessage.error(`请求错误: ${message}`)
        break
      case 401:
        ElMessage.error('登录已过期，请重新登录')
        // 跳转到登录页
        break
      case 403:
        ElMessage.error('没有权限执行此操作')
        break
      case 404:
        ElMessage.error('请求的资源不存在')
        break
      case 500:
        ElMessage.error('服务器内部错误')
        break
      default:
        ElMessage.error(`请求失败: ${message}`)
    }
    
    return Promise.reject(error)
  }
)

export default request
```

### 3.2 完整API模块示例

```typescript
// api/drama.ts
import type {
  CreateDramaRequest,
  Drama,
  DramaListQuery,
  DramaStats,
  UpdateDramaRequest,
  Character,
  Episode,
  Scene
} from '@/types/drama'
import request from '@/utils/request'

// 类型定义
export interface DramaListResponse {
  items: Drama[]
  pagination: {
    page: number
    page_size: number
    total: number
    total_pages: number
  }
}

export interface CreateDramaResponse {
  id: number
  title: string
  status: string
  created_at: string
}

// API函数集合
export const dramaAPI = {
  // ==================== 短剧CRUD ====================
  
  /** 获取短剧列表 */
  list(params?: DramaListQuery) {
    return request.get<DramaListResponse>('/dramas', { params })
  },
  
  /** 创建短剧 */
  create(data: CreateDramaRequest) {
    return request.post<CreateDramaResponse>('/dramas', data)
  },
  
  /** 获取短剧详情 */
  get(id: string) {
    return request.get<Drama>(`/dramas/${id}`)
  },
  
  /** 更新短剧 */
  update(id: string, data: UpdateDramaRequest) {
    return request.put<Drama>(`/dramas/${id}`, data)
  },
  
  /** 删除短剧 */
  delete(id: string) {
    return request.delete(`/dramas/${id}`)
  },
  
  /** 获取统计信息 */
  getStats() {
    return request.get<DramaStats>('/dramas/stats')
  },
  
  // ==================== 大纲管理 ====================
  
  saveOutline(id: string, data: { title: string; summary: string; genre?: string; tags?: string[] }) {
    return request.put(`/dramas/${id}/outline`, data)
  },
  
  // ==================== 角色管理 ====================
  
  getCharacters(dramaId: string) {
    return request.get<Character[]>(`/dramas/${dramaId}/characters`)
  },
  
  saveCharacters(id: string, characters: Character[], episodeId?: string) {
    return request.put(`/dramas/${id}/characters`, {
      characters,
      episode_id: episodeId ? parseInt(episodeId) : undefined
    })
  },
  
  updateCharacter(id: number, data: Partial<Character>) {
    return request.put<Character>(`/characters/${id}`, data)
  },
  
  // ==================== 章节管理 ====================
  
  saveEpisodes(id: string, episodes: Episode[]) {
    return request.put(`/dramas/${id}/episodes`, { episodes })
  },
  
  // ==================== 场景管理 ====================
  
  updateScene(sceneId: string, data: Partial<Scene>) {
    return request.put<Scene>(`/scenes/${sceneId}`, data)
  },
  
  createScene(data: Omit<Scene, 'id' | 'created_at' | 'updated_at'>) {
    return request.post<Scene>('/scenes', data)
  },
  
  deleteScene(sceneId: string) {
    return request.delete(`/scenes/${sceneId}`)
  },
  
  // ==================== 图片生成 ====================
  
  generateSceneImage(data: { scene_id: number; prompt?: string; model?: string }) {
    return request.post<{ image_generation: { id: number } }>('/scenes/generate-image', data)
  },
  
  extractBackgrounds(episodeId: string, model?: string) {
    return request.post<{ task_id: string; status: string }>(
      `/images/episode/${episodeId}/backgrounds/extract`,
      { model }
    )
  },
  
  // ==================== 分镜管理 ====================
  
  generateStoryboard(episodeId: string) {
    return request.post(`/episodes/${episodeId}/storyboards`)
  },
  
  updateStoryboard(storyboardId: string, data: any) {
    return request.put(`/storyboards/${storyboardId}`, data)
  },
  
  // ==================== 视频导出 ====================
  
  finalizeEpisode(episodeId: string, timelineData?: any) {
    return request.post(`/episodes/${episodeId}/finalize`, timelineData || {})
  }
}

export default dramaAPI
```

### 3.3 加载状态管理

```vue
<!-- 组件中管理加载状态 -->
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { dramaAPI } from '@/api/drama'
import type { Drama } from '@/types/drama'

const dramas = ref<Drama[]>([])
const loading = ref(false)
const error = ref<string | null>(null)

const loadDramas = async () => {
  // 防止重复请求
  if (loading.value) return
  
  loading.value = true
  error.value = null
  
  try {
    const response = await dramaAPI.list()
    dramas.value = response.items
  } catch (err: any) {
    error.value = err.message
  } finally {
    loading.value = false
  }
}

onMounted(() => {
  loadDramas()
})
</script>

<template>
  <div v-loading="loading" class="drama-list">
    <div v-if="error" class="error-message">
      {{ error }}
      <el-button @click="loadDramas">重试</el-button>
    </div>
    
    <DramaCard 
      v-for="drama in dramas" 
      :key="drama.id" 
      :drama="drama" 
    />
  </div>
</template>
```

### 3.4 请求取消

```typescript
// utils/request.ts
// 添加请求取消支持

import axios from 'axios'

// 存储正在进行的请求
const pendingRequests = new Map<string, AbortController>()

// 生成请求key
const getRequestKey = (config: any) => {
  return `${config.method}_${config.url}`
}

// 添加请求拦截器
request.interceptors.request.use(
  (config) => {
    // 创建AbortController
    const controller = new AbortController()
    config.signal = controller.signal
    
    // 取消重复请求
    const key = getRequestKey(config)
    if (pendingRequests.has(key)) {
      pendingRequests.get(key)?.abort()
      pendingRequests.delete(key)
    }
    
    pendingRequests.set(key, controller)
    return config
  }
)

// 添加响应拦截器
request.interceptors.response.use(
  (response) => {
    // 请求完成，移除
    const key = getRequestKey(response.config)
    pendingRequests.delete(key)
    return response
  },
  (error) => {
    // 请求失败，移除
    if (error.config) {
      const key = getRequestKey(error.config)
      pendingRequests.delete(key)
    }
    return Promise.reject(error)
  }
)

// 组件中使用
import { onUnmounted } from 'vue'

const controller = new AbortController()

const fetchData = async () => {
  try {
    const data = await request.get('/api/data', {
      signal: controller.signal
    })
    return data
  } catch (err: any) {
    if (err.name === 'AbortError') {
      console.log('请求已取消')
      return
    }
    throw err
  }
}

// 组件卸载时取消请求
onUnmounted(() => {
  controller.abort()
})
```

## 4. UI组件使用（Element Plus）

### 4.1 表单组件

```vue
<template>
  <el-form
    ref="formRef"
    :model="form"
    :rules="rules"
    label-position="top"
    @submit.prevent="handleSubmit"
  >
    <!-- 文本输入 -->
    <el-form-item label="短剧标题" prop="title">
      <el-input
        v-model="form.title"
        placeholder="请输入短剧标题"
        maxlength="200"
        show-word-limit
        clearable
      />
    </el-form-item>
    
    <!-- 文本域 -->
    <el-form-item label="剧情简介" prop="description">
      <el-input
        v-model="form.description"
        type="textarea"
        :rows="4"
        placeholder="请输入剧情简介"
        resize="none"
      />
    </el-form-item>
    
    <!-- 下拉选择 -->
    <el-form-item label="类型" prop="genre">
      <el-select v-model="form.genre" placeholder="请选择类型" clearable>
        <el-option
          v-for="item in genreOptions"
          :key="item.value"
          :label="item.label"
          :value="item.value"
        />
      </el-select>
    </el-form-item>
    
    <!-- 多选 -->
    <el-form-item label="标签" prop="tags">
      <el-select
        v-model="form.tags"
        multiple
        filterable
        allow-create
        default-first-option
        placeholder="请选择或输入标签"
      >
        <el-option
          v-for="tag in tagOptions"
          :key="tag"
          :label="tag"
          :value="tag"
        />
      </el-select>
    </el-form-item>
    
    <!-- 日期选择 -->
    <el-form-item label="计划发布日期" prop="publishDate">
      <el-date-picker
        v-model="form.publishDate"
        type="date"
        placeholder="选择日期"
        :disabled-date="disabledDate"
      />
    </el-form-item>
    
    <!-- 数字输入 -->
    <el-form-item label="集数" prop="episodes">
      <el-input-number
        v-model="form.episodes"
        :min="1"
        :max="100"
        :step="1"
      />
    </el-form-item>
    
    <!-- 开关 -->
    <el-form-item label="是否公开" prop="isPublic">
      <el-switch v-model="form.isPublic" />
    </el-form-item>
    
    <!-- 单选 -->
    <el-form-item label="风格" prop="style">
      <el-radio-group v-model="form.style">
        <el-radio label="realistic">写实</el-radio>
        <el-radio label="anime">动漫</el-radio>
        <el-radio label="3d">3D</el-radio>
      </el-radio-group>
    </el-form-item>
    
    <!-- 操作按钮 -->
    <el-form-item>
      <el-button type="primary" :loading="submitting" @click="handleSubmit">
        提交
      </el-button>
      <el-button @click="handleReset">重置</el-button>
    </el-form-item>
  </el-form>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue'
import type { FormInstance, FormRules } from 'element-plus'

const formRef = ref<FormInstance>()
const submitting = ref(false)

const form = reactive({
  title: '',
  description: '',
  genre: '',
  tags: [],
  publishDate: null,
  episodes: 1,
  isPublic: true,
  style: 'realistic'
})

const rules: FormRules = {
  title: [
    { required: true, message: '请输入短剧标题', trigger: 'blur' },
    { min: 1, max: 200, message: '标题长度应在1-200个字符', trigger: 'blur' }
  ],
  genre: [
    { required: true, message: '请选择类型', trigger: 'change' }
  ],
  episodes: [
    { required: true, message: '请输入集数', trigger: 'change' },
    { type: 'number', min: 1, message: '集数至少为1', trigger: 'change' }
  ]
}

const genreOptions = [
  { label: '喜剧', value: 'comedy' },
  { label: '爱情', value: 'romance' },
  { label: '悬疑', value: 'mystery' },
  { label: '科幻', value: 'scifi' },
  { label: '动作', value: 'action' }
]

const tagOptions = ['热门', '推荐', '独家', '首发']

const disabledDate = (time: Date) => {
  return time.getTime() < Date.now() - 8.64e7
}

const handleSubmit = async () => {
  if (!formRef.value) return
  
  const valid = await formRef.value.validate().catch(() => false)
  if (!valid) return
  
  submitting.value = true
  try {
    // 提交逻辑
    await submitForm(form)
    ElMessage.success('提交成功')
  } catch (error) {
    ElMessage.error('提交失败')
  } finally {
    submitting.value = false
  }
}

const handleReset = () => {
  formRef.value?.resetFields()
}
</script>
```

### 4.2 数据展示组件

```vue
<template>
  <!-- 表格 -->
  <el-table
    :data="tableData"
    v-loading="loading"
    @selection-change="handleSelectionChange"
  >
    <el-table-column type="selection" width="55" />
    <el-table-column prop="title" label="标题" min-width="200">
      <template #default="{ row }">
        <div class="title-cell">
          <img :src="row.thumbnail" class="row-thumbnail" />
          <span>{{ row.title }}</span>
        </div>
      </template>
    </el-table-column>
    <el-table-column prop="status" label="状态" width="120">
      <template #default="{ row }">
        <el-tag :type="getStatusType(row.status)">
          {{ getStatusLabel(row.status) }}
        </el-tag>
      </template>
    </el-table-column>
    <el-table-column prop="updatedAt" label="更新时间" width="180">
      <template #default="{ row }">
        {{ formatDate(row.updatedAt) }}
      </template>
    </el-table-column>
    <el-table-column label="操作" width="200" fixed="right">
      <template #default="{ row }">
        <el-button type="primary" size="small" @click="handleEdit(row)">
          编辑
        </el-button>
        <el-button type="danger" size="small" @click="handleDelete(row)">
          删除
        </el-button>
      </template>
    </el-table-column>
  </el-table>
  
  <!-- 分页 -->
  <el-pagination
    v-model:current-page="currentPage"
    v-model:page-size="pageSize"
    :page-sizes="[10, 20, 50, 100]"
    :total="total"
    layout="total, sizes, prev, pager, next, jumper"
    @size-change="handleSizeChange"
    @current-change="handleCurrentChange"
  />
  
  <!-- 卡片列表 -->
  <div class="card-list">
    <el-card
      v-for="item in listData"
      :key="item.id"
      :body-style="{ padding: '0px' }"
      shadow="hover"
    >
      <img :src="item.cover" class="card-image" />
      <div class="card-content">
        <h4>{{ item.title }}</h4>
        <p>{{ item.description }}</p>
        <div class="card-footer">
          <el-button type="primary" size="small">查看</el-button>
        </div>
      </div>
    </el-card>
  </div>
</template>
```

### 4.3 反馈组件

```typescript
// Message 消息提示
import { ElMessage } from 'element-plus'

ElMessage.success('操作成功')
ElMessage.error('操作失败')
ElMessage.warning('警告信息')
ElMessage.info('提示信息')

// 带关闭按钮
ElMessage({
  message: '这是一条消息',
  type: 'success',
  showClose: true,
  duration: 3000
})

// Notification 通知
import { ElNotification } from 'element-plus'

ElNotification.success({
  title: '成功',
  message: '短剧创建成功',
  duration: 3000
})

ElNotification.error({
  title: '错误',
  message: '服务器连接失败',
  duration: 0  // 不自动关闭
})

// Dialog 对话框
import { ElMessageBox } from 'element-plus'

// 确认对话框
await ElMessageBox.confirm(
  '确定要删除该短剧吗？此操作不可恢复',
  '警告',
  {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }
)

// 提示对话框
await ElMessageBox.prompt('请输入短剧名称', '创建短剧', {
  confirmButtonText: '确定',
  cancelButtonText: '取消',
  inputPattern: /^.{1,200}$/,
  inputErrorMessage: '标题长度应在1-200个字符'
})

// Loading 加载
import { ElLoading } from 'element-plus'

const loading = ElLoading.service({
  lock: true,
  text: '加载中...',
  background: 'rgba(0, 0, 0, 0.7)'
})

loading.close()
```

## 5. 路由与导航

### 5.1 路由配置

```typescript
// router/index.ts
import type { RouteRecordRaw } from 'vue-router'
import { createRouter, createWebHistory } from 'vue-router'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'DramaList',
    component: () => import('@/views/drama/DramaList.vue'),
    meta: {
      title: '短剧列表',
      keepAlive: true
    }
  },
  {
    path: '/dramas/create',
    name: 'DramaCreate',
    component: () => import('@/views/drama/DramaCreate.vue'),
    meta: {
      title: '创建短剧'
    }
  },
  {
    path: '/dramas/:id',
    name: 'DramaManagement',
    component: () => import('@/views/drama/DramaManagement.vue'),
    meta: {
      title: '短剧管理',
      requiresAuth: false  // 开源版本无需认证
    }
  },
  {
    path: '/dramas/:id/episode/:episodeNumber',
    name: 'EpisodeWorkflow',
    component: () => import('@/views/drama/EpisodeWorkflow.vue'),
    props: true,  // 将路由参数作为props传递
    meta: {
      title: '章节制作'
    }
  },
  {
    path: '/episodes/:id/edit',
    name: 'ScriptEdit',
    component: () => import('@/views/script/ScriptEdit.vue')
  },
  {
    path: '/timeline/:id',
    name: 'TimelineEditor',
    component: () => import('@/views/editor/TimelineEditor.vue')
  },
  {
    path: '/settings/ai-config',
    name: 'AIConfig',
    component: () => import('@/views/settings/AIConfig.vue'),
    meta: {
      title: 'AI配置'
    }
  },
  // 404页面
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/views/error/NotFound.vue')
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes,
  scrollBehavior(to, from, savedPosition) {
    // 滚动行为
    if (savedPosition) {
      return savedPosition
    } else {
      return { top: 0 }
    }
  }
})

// 路由守卫
router.beforeEach((to, from, next) => {
  // 设置页面标题
  document.title = to.meta.title ? `${to.meta.title} - 火宝短剧` : '火宝短剧'
  
  // 开源版本 - 无需认证检查
  // if (to.meta.requiresAuth && !isAuthenticated()) {
  //   next({ name: 'Login', query: { redirect: to.fullPath } })
  //   return
  // }
  
  next()
})

export default router
```

### 5.2 路由守卫示例

```typescript
// 认证检查守卫
router.beforeEach(async (to, from, next) => {
  const userStore = useUserStore()
  
  // 需要认证的路由
  if (to.meta.requiresAuth && !userStore.isLoggedIn) {
    next({
      path: '/login',
      query: { redirect: to.fullPath }
    })
    return
  }
  
  // 需要管理员权限
  if (to.meta.requiresAdmin && !userStore.isAdmin) {
    next({ path: '/403' })
    return
  }
  
  // 已登录用户访问登录页，重定向到首页
  if (to.path === '/login' && userStore.isLoggedIn) {
    next({ path: '/' })
    return
  }
  
  next()
})

// 动态路由（权限路由）
const generateRoutes = (permissions: string[]): RouteRecordRaw[] => {
  const routes: RouteRecordRaw[] = []
  
  if (permissions.includes('drama:create')) {
    routes.push({
      path: '/dramas/create',
      name: 'DramaCreate',
      component: () => import('@/views/drama/DramaCreate.vue')
    })
  }
  
  return routes
}
```

### 5.3 路由使用

```vue
<script setup lang="ts">
import { useRoute, useRouter } from 'vue-router'

const route = useRoute()
const router = useRouter()

// 获取路由参数
const dramaId = route.params.id as string
const episodeNumber = parseInt(route.params.episodeNumber as string)
const queryPage = parseInt(route.query.page as string) || 1

// 获取meta信息
const pageTitle = route.meta.title

// 编程式导航
const goToDrama = (id: string) => {
  router.push(`/dramas/${id}`)
}

const goToDramaByName = (id: string) => {
  router.push({
    name: 'DramaManagement',
    params: { id }
  })
}

const goToEpisode = (dramaId: string, episodeNum: number) => {
  router.push({
    name: 'EpisodeWorkflow',
    params: {
      id: dramaId,
      episodeNumber: episodeNum
    },
    query: {
      step: 'script'
    }
  })
}

// 替换当前路由（不留下历史记录）
const replaceRoute = () => {
  router.replace({ path: '/new-path' })
}

// 返回上一页
const goBack = () => {
  router.back()
}

// 前进
const goForward = () => {
  router.forward()
}
</script>
```

## 6. 最佳实践

### 6.1 Composable提取

```typescript
// composables/useDrama.ts
import { ref, computed, onMounted } from 'vue'
import { dramaAPI } from '@/api/drama'
import type { Drama, DramaListQuery } from '@/types/drama'

export function useDrama(query?: DramaListQuery) {
  const dramas = ref<Drama[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)
  const total = ref(0)
  
  const hasDramas = computed(() => dramas.value.length > 0)
  
  const fetchDramas = async (params?: DramaListQuery) => {
    loading.value = true
    error.value = null
    
    try {
      const response = await dramaAPI.list({ ...query, ...params })
      dramas.value = response.items
      total.value = response.pagination.total
      return response
    } catch (err: any) {
      error.value = err.message
      throw err
    } finally {
      loading.value = false
    }
  }
  
  const refresh = () => fetchDramas()
  
  onMounted(() => {
    fetchDramas()
  })
  
  return {
    dramas,
    loading,
    error,
    total,
    hasDramas,
    fetchDramas,
    refresh
  }
}

// composables/useFetch.ts - 通用请求封装
import { ref, watchEffect, onUnmounted } from 'vue'

export function useFetch<T>(
  url: string | (() => string),
  options?: RequestInit
) {
  const data = ref<T | null>(null)
  const error = ref<Error | null>(null)
  const loading = ref(false)
  
  const controller = new AbortController()
  
  const execute = async () => {
    loading.value = true
    error.value = null
    
    try {
      const response = await fetch(
        typeof url === 'function' ? url() : url,
        {
          ...options,
          signal: controller.signal
        }
      )
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      
      data.value = await response.json()
    } catch (err: any) {
      if (err.name !== 'AbortError') {
        error.value = err
      }
    } finally {
      loading.value = false
    }
  }
  
  watchEffect(() => {
    execute()
  })
  
  onUnmounted(() => {
    controller.abort()
  })
  
  return { data, error, loading, execute }
}

// 使用示例
// components/DramaList.vue
import { useDrama } from '@/composables/useDrama'

const { dramas, loading, error, total, refresh } = useDrama({
  page: 1,
  page_size: 12
})
```

### 6.2 性能优化

```vue
<template>
  <!-- v-once - 一次性渲染，不再更新 -->
  <div v-once>
    <h1>{{ staticTitle }}</h1>
    <p>{{ staticDescription }}</p>
  </div>
  
  <!-- v-memo - 条件性更新 -->
  <div v-memo="[item.id, item.status]">
    <!-- 仅当item.id或item.status变化时更新 -->
    <ComplexComponent :data="item" />
  </div>
  
  <!-- keep-alive - 缓存组件状态 -->
  <keep-alive :include="['DramaList']">
    <component :is="currentComponent" />
  </keep-alive>
  
  <!-- 虚拟列表（大数据量） -->
  <el-virtual-list :data="largeList" :item-size="50">
    <template #default="{ item }">
      <ListItem :item="item" />
    </template>
  </el-virtual-list>
</template>

<script setup lang="ts">
// 懒加载组件
const DramaDetail = defineAsyncComponent(() => 
  import('@/views/drama/DramaDetail.vue')
)

// 路由懒加载（已配置）
// component: () => import('@/views/drama/DramaList.vue')

// 防抖处理
import { debounce } from 'lodash-es'

const searchDramas = debounce(async (keyword: string) => {
  await dramaAPI.search({ keyword })
}, 300)

// 图片懒加载
// <img v-lazy="imageUrl" />
</script>
```

### 6.3 TypeScript严格模式

```json
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

```typescript
// 类型定义示例
// types/drama.ts
export interface Drama {
  id: string | number
  title: string
  description?: string
  genre?: string
  style: 'realistic' | 'anime' | '3d'
  status: 'draft' | 'planning' | 'production' | 'completed' | 'archived'
  thumbnail?: string
  tags?: string[]
  metadata?: Record<string, any>
  totalEpisodes: number
  totalDuration: number
  createdAt: string
  updatedAt: string
}

export interface CreateDramaRequest {
  title: string
  description?: string
  genre?: string
  tags?: string[]
}

export interface UpdateDramaRequest extends Partial<CreateDramaRequest> {
  status?: Drama['status']
}

export interface DramaListQuery {
  page?: number
  page_size?: number
  status?: string
  genre?: string
  keyword?: string
}

export interface DramaStats {
  total: number
  byStatus: Array<{ status: string; count: number }>
}
```
