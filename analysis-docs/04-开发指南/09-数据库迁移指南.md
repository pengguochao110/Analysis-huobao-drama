# 09-数据库迁移指南

## 1. GORM迁移基础

### 1.1 AutoMigrate原理

GORM的AutoMigrate机制会自动完成以下操作：

```
AutoMigrate流程：
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   读取Model  │ ──→ │  对比数据库  │ ──→ │  生成DDL语句 │
│   结构体定义 │     │  实际结构    │     │  (ALTER等)   │
└──────────────┘     └──────────────┘     └──────────────┘
                                                  ↓
                                          ┌──────────────┐
                                          │  执行迁移    │
                                          │  更新数据库  │
                                          └──────────────┘
```

**AutoMigrate能做什么**：
- ✅ 创建新表
- ✅ 添加缺失的列
- ✅ 创建索引
- ✅ 创建外键约束
- ✅ 支持多种数据库（SQLite、MySQL、PostgreSQL）

**AutoMigrate不能做什么**：
- ❌ 删除列（避免数据丢失）
- ❌ 修改列类型（可能丢失数据）
- ❌ 重命名列（会创建新列）
- ❌ 复杂的表结构重组

### 1.2 迁移vs手动SQL对比

| 场景 | AutoMigrate | 手动SQL |
|------|------------|---------|
| 新增表 | ✅ 推荐 | 可选 |
| 新增字段（nullable） | ✅ 推荐 | 可选 |
| 新增字段（not null） | ⚠️ 需默认值 | ✅ 推荐 |
| 修改字段类型 | ❌ 不支持 | ✅ 必须 |
| 删除字段 | ❌ 不支持 | ✅ 必须 |
| 重命名字段 | ❌ 不支持 | ✅ 必须 |
| 数据迁移 | ❌ 不支持 | ✅ 必须 |
| 复杂索引 | ⚠️ 有限支持 | ✅ 推荐 |

### 1.3 迁移策略选择

```go
// 策略1：纯AutoMigrate（适合快速开发）
func AutoMigrateAll(db *gorm.DB) error {
    return db.AutoMigrate(
        &models.Drama{},
        &models.Episode{},
        &models.Character{},
        &models.Scene{},
        &models.Storyboard{},
        &models.Prop{},
        // ...
    )
}

// 策略2：版本化迁移（生产环境推荐）
// 使用gormigrate管理版本
import "github.com/go-gormigrate/gormigrate/v2"

var migrations = []*gormigrate.Migration{
    {
        ID: "2024010101",
        Migrate: func(tx *gorm.DB) error {
            return tx.AutoMigrate(&models.Drama{})
        },
        Rollback: func(tx *gorm.DB) error {
            return tx.Migrator().DropTable("dramas")
        },
    },
    {
        ID: "2024010102",
        Migrate: func(tx *gorm.DB) error {
            return tx.AutoMigrate(&models.Episode{})
        },
        Rollback: func(tx *gorm.DB) error {
            return tx.Migrator().DropTable("episodes")
        },
    },
}

func RunMigrations(db *gorm.DB) error {
    m := gormigrate.New(db, gormigrate.DefaultOptions, migrations)
    return m.Migrate()
}
```

### 1.4 版本控制（gormigrate使用）

```go
// cmd/migrate/main.go - 数据库迁移命令行工具
package main

import (
    "flag"
    "fmt"
    "log"
    
    "github.com/drama-generator/backend/domain/models"
    "github.com/drama-generator/backend/pkg/config"
    "github.com/drama-generator/backend/pkg/logger"
    "github.com/go-gormigrate/gormigrate/v2"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

func main() {
    var action string
    flag.StringVar(&action, "action", "up", "Migration action: up, down, status")
    flag.Parse()

    // 初始化数据库连接
    db, err := initDB()
    if err != nil {
        log.Fatal(err)
    }

    m := gormigrate.New(db, gormigrate.DefaultOptions, getMigrations())

    switch action {
    case "up":
        if err := m.Migrate(); err != nil {
            log.Fatal(err)
        }
        fmt.Println("Migration completed successfully")
    
    case "down":
        if err := m.RollbackLast(); err != nil {
            log.Fatal(err)
        }
        fmt.Println("Rollback completed successfully")
    
    case "status":
        // 显示迁移状态
        for _, migration := range getMigrations() {
            var count int64
            db.Table("migrations").Where("id = ?", migration.ID).Count(&count)
            status := "Pending"
            if count > 0 {
                status = "Applied"
            }
            fmt.Printf("[%s] %s\n", status, migration.ID)
        }
    
    default:
        fmt.Println("Unknown action. Use: up, down, status")
    }
}

func initDB() (*gorm.DB, error) {
    cfg := config.Load()
    log := logger.NewLogger(true)
    
    db, err := gorm.Open(sqlite.Open(cfg.Database.Path), &gorm.Config{
        Logger: logger.NewGORMLogger(log, cfg.Database.LogLevel),
    })
    if err != nil {
        return nil, err
    }
    
    return db, nil
}

func getMigrations() []*gormigrate.Migration {
    return []*gormigrate.Migration{
        // v1.0.0 - 初始表结构
        {
            ID: "2024010101_init_schema",
            Migrate: func(tx *gorm.DB) error {
                return tx.AutoMigrate(
                    &models.Drama{},
                    &models.Episode{},
                    &models.Character{},
                )
            },
            Rollback: func(tx *gorm.DB) error {
                return tx.Migrator().DropTable(
                    "dramas", "episodes", "characters",
                )
            },
        },
        // v1.1.0 - 添加场景表
        {
            ID: "2024011501_add_scenes",
            Migrate: func(tx *gorm.DB) error {
                return tx.AutoMigrate(&models.Scene{})
            },
            Rollback: func(tx *gorm.DB) error {
                return tx.Migrator().DropTable("scenes")
            },
        },
        // v1.2.0 - 添加标签功能
        {
            ID: "2024020101_add_tags",
            Migrate: func(tx *gorm.DB) error {
                // 添加tags列
                if !tx.Migrator().HasColumn(&models.Drama{}, "Tags") {
                    if err := tx.Exec("ALTER TABLE dramas ADD COLUMN tags JSON").Error; err != nil {
                        return err
                    }
                }
                return nil
            },
            Rollback: func(tx *gorm.DB) error {
                // SQLite不支持DROP COLUMN，需要重建表
                return recreateTableWithoutColumn(tx, "dramas", "tags")
            },
        },
    }
}
```

## 2. 新增表迁移

### 2.1 Step by Step：新增Tag表

```go
// Step 1: 定义Model结构体
// domain/models/tag.go
package models

import (
    "time"
    "gorm.io/gorm"
)

type Tag struct {
    ID          uint           `gorm:"primaryKey;autoIncrement" json:"id"`
    Name        string         `gorm:"type:varchar(50);not null;uniqueIndex" json:"name"`
    Color       string         `gorm:"type:varchar(7);default:'#1890ff'" json:"color"` // Hex颜色
    Description string         `gorm:"type:varchar(200)" json:"description"`
    CreatedAt   time.Time      `gorm:"autoCreateTime" json:"created_at"`
    UpdatedAt   time.Time      `gorm:"autoUpdateTime" json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`
    
    // 多对多关系
    Dramas []Drama `gorm:"many2many:drama_tags;" json:"dramas,omitempty"`
}

func (Tag) TableName() string {
    return "tags"
}

// Step 2: 添加到AutoMigrate列表
// infrastructure/database/database.go
func AutoMigrate(db *gorm.DB) error {
    return db.AutoMigrate(
        &models.Drama{},
        &models.Episode{},
        &models.Character{},
        &models.Scene{},
        &models.Storyboard{},
        &models.Prop{},
        &models.Tag{},           // ← 新增
    )
}

// Step 3: 运行迁移
// 启动应用时会自动执行

// 或者手动执行
// cmd/migrate/main.go 中添加
{
    ID: "2024021501_add_tags_table",
    Migrate: func(tx *gorm.DB) error {
        return tx.AutoMigrate(&models.Tag{})
    },
    Rollback: func(tx *gorm.DB) error {
        return tx.Migrator().DropTable("tags", "drama_tags")
    },
}

// Step 4: 验证迁移结果
// 使用sqlite3命令行或GORM检查
func VerifyMigration(db *gorm.DB) {
    // 检查表是否存在
    hasTable := db.Migrator().HasTable("tags")
    fmt.Printf("Table 'tags' exists: %v\n", hasTable)
    
    // 检查列
    hasName := db.Migrator().HasColumn(&models.Tag{}, "Name")
    fmt.Printf("Column 'name' exists: %v\n", hasName)
    
    // 检查索引
    hasIndex := db.Migrator().HasIndex(&models.Tag{}, "idx_tags_name")
    fmt.Printf("Index 'idx_tags_name' exists: %v\n", hasIndex)
}
```

### 2.2 完整示例：新增Tag表（含关联）

```go
// domain/models/tag.go
package models

import (
    "time"
    "gorm.io/gorm"
)

// Tag 标签表
type Tag struct {
    ID          uint           `gorm:"primaryKey;autoIncrement" json:"id"`
    Name        string         `gorm:"type:varchar(50);not null;uniqueIndex:idx_tags_name" json:"name"`
    Color       string         `gorm:"type:varchar(7);default:'#1890ff'" json:"color"`
    Description string         `gorm:"type:varchar(200)" json:"description"`
    UsageCount  int            `gorm:"default:0" json:"usage_count"` // 使用次数统计
    CreatedAt   time.Time      `gorm:"autoCreateTime" json:"created_at"`
    UpdatedAt   time.Time      `gorm:"autoUpdateTime" json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`
}

func (Tag) TableName() string {
    return "tags"
}

// DramaTag 短剧-标签关联表（自动创建）
// GORM会自动创建这个关联表
type DramaTag struct {
    DramaID uint `gorm:"primaryKey"`
    TagID   uint `gorm:"primaryKey"`
}

// 在Drama模型中添加关联
// domain/models/drama.go
type Drama struct {
    // ... 其他字段
    Tags []Tag `gorm:"many2many:drama_tags;" json:"tags,omitempty"`
}

// 创建带索引的迁移
// cmd/migrate/main.go
{
    ID: "2024021501_create_tags",
    Migrate: func(tx *gorm.DB) error {
        // 创建标签表
        if err := tx.AutoMigrate(&models.Tag{}); err != nil {
            return err
        }
        
        // 创建关联表（手动控制以获得更好性能）
        if !tx.Migrator().HasTable("drama_tags") {
            if err := tx.Exec(`
                CREATE TABLE drama_tags (
                    drama_id INTEGER NOT NULL,
                    tag_id INTEGER NOT NULL,
                    PRIMARY KEY (drama_id, tag_id),
                    FOREIGN KEY (drama_id) REFERENCES dramas(id) ON DELETE CASCADE,
                    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
                )
            `).Error; err != nil {
                return err
            }
            
            // 添加索引
            if err := tx.Exec(`
                CREATE INDEX idx_drama_tags_drama_id ON drama_tags(drama_id);
                CREATE INDEX idx_drama_tags_tag_id ON drama_tags(tag_id);
            `).Error; err != nil {
                return err
            }
        }
        
        return nil
    },
    Rollback: func(tx *gorm.DB) error {
        if err := tx.Migrator().DropTable("drama_tags"); err != nil {
            return err
        }
        if err := tx.Migrator().DropTable("tags"); err != nil {
            return err
        }
        return nil
    },
}
```

### 2.3 索引创建

```go
// 单字段索引
Tag struct {
    Name string `gorm:"index"`  // 默认索引名: idx_tags_name
}

// 指定索引名
Tag struct {
    Name string `gorm:"index:idx_name"`
}

// 唯一索引
Tag struct {
    Name string `gorm:"uniqueIndex"`
}

// 复合索引
Drama struct {
    Status    string `gorm:"index:idx_status_updated"`
    UpdatedAt time.Time `gorm:"index:idx_status_updated"`
}

// 多列复合索引（推荐）
Storyboard struct {
    EpisodeID        uint `gorm:"index:idx_episode_number"`
    StoryboardNumber int  `gorm:"index:idx_episode_number"`
}

// 索引选项
Tag struct {
    // 指定排序方式（仅部分数据库支持）
    Name string `gorm:"index:,sort:desc,collate:utf8_general_ci"`
    
    // 指定索引类型（MySQL）
    SearchText string `gorm:"index:,class:FULLTEXT,option:WITH PARSER ngram"`
    
    // 部分索引条件（PostgreSQL）
    Active bool `gorm:"index:,where:active = true"`
}
```

### 2.4 外键关系

```go
// BelongsTo - 属于
Comment struct {
    ID      uint `gorm:"primaryKey"`
    DramaID uint `gorm:"not null;index"`
    Drama   Drama `gorm:"foreignKey:DramaID"`  // 外键关联
    Content string
}

// HasMany - 拥有多个
Drama struct {
    ID       uint `gorm:"primaryKey"`
    Episodes []Episode `gorm:"foreignKey:DramaID"`  // 一对多
}

// HasOne - 拥有一个
Drama struct {
    ID          uint `gorm:"primaryKey"`
    Statistics  DramaStatistics `gorm:"foreignKey:DramaID"`  // 一对一
}

// Many2Many - 多对多
Drama struct {
    ID     uint `gorm:"primaryKey"`
    Tags   []Tag `gorm:"many2many:drama_tags;"`  // 多对多
}

// 自定义外键约束
Storyboard struct {
    EpisodeID uint `gorm:"not null;index"`
    Episode   Episode `gorm:"foreignKey:EpisodeID;constraint:OnDelete:CASCADE;"`
    // 删除Episode时级联删除Storyboard
}

// 高级外键配置
Comment struct {
    DramaID uint
    Drama   Drama `gorm:"foreignKey:DramaID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:SET NULL;"`
    // Drama更新时级联更新
    // Drama删除时设为NULL
}
```

### 2.5 回滚策略

```go
// 安全回滚模式
{
    ID: "2024021501_add_feature",
    Migrate: func(tx *gorm.DB) error {
        return tx.AutoMigrate(&models.NewFeature{})
    },
    Rollback: func(tx *gorm.DB) error {
        // 策略1：保留数据（软回滚）
        // 仅标记为废弃，不删除表
        return tx.Exec("ALTER TABLE new_features RENAME TO new_features_deprecated").Error
        
        // 策略2：删除表（硬回滚）
        // return tx.Migrator().DropTable("new_features")
        
        // 策略3：备份后删除
        // if err := backupTable(tx, "new_features"); err != nil {
        //     return err
        // }
        // return tx.Migrator().DropTable("new_features")
    },
}

// 备份表函数
func backupTable(db *gorm.DB, tableName string) error {
    backupName := fmt.Sprintf("%s_backup_%s", tableName, time.Now().Format("20060102_150405"))
    return db.Exec(fmt.Sprintf("ALTER TABLE %s RENAME TO %s", tableName, backupName)).Error
}
```

## 3. 修改现有表

### 3.1 新增字段

```go
// 场景1：新增nullable字段（简单）
// 直接修改Model后运行AutoMigrate

Drama struct {
    // 原有字段...
    NewField *string `gorm:"type:varchar(100)" json:"new_field,omitempty"`  // nullable
}

// 场景2：新增not null字段（需要默认值）
Drama struct {
    // 方式1：使用default标签
    Status string `gorm:"type:varchar(20);not null;default:'draft'" json:"status"`
    
    // 方式2：使用指针+钩子
    PublishedAt *time.Time `json:"published_at,omitempty"`
}

// 方式3：分步迁移（生产环境推荐）
// 步骤1：添加nullable字段
{
    ID: "2024022001_add_status",
    Migrate: func(tx *gorm.DB) error {
        // 添加nullable列
        return tx.Exec("ALTER TABLE dramas ADD COLUMN status varchar(20)").Error
    },
}

// 步骤2：填充数据
{
    ID: "2024022002_populate_status",
    Migrate: func(tx *gorm.DB) error {
        // 根据已有数据填充
        return tx.Exec("UPDATE dramas SET status = 'draft' WHERE status IS NULL").Error
    },
}

// 步骤3：添加约束
{
    ID: "2024022003_add_status_constraint",
    Migrate: func(tx *gorm.DB) error {
        // SQLite不支持ALTER COLUMN，需要重建表
        return recreateTableWithNotNull(tx, "dramas", "status", "draft")
    },
}
```

### 3.2 修改字段类型

```go
// 场景：修改Description字段类型 varchar(200) → text

// GORM限制：AutoMigrate不修改字段类型
// 需要手动迁移

{
    ID: "2024022501_change_description_type",
    Migrate: func(tx *gorm.DB) error {
        // SQLite：需要重建表
        return tx.Transaction(func(db *gorm.DB) error {
            // 1. 创建新表
            if err := db.Exec(`
                CREATE TABLE dramas_new (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title varchar(200) NOT NULL,
                    description text,  -- 修改后的类型
                    -- ... 其他字段
                )
            `).Error; err != nil {
                return err
            }
            
            // 2. 复制数据
            if err := db.Exec(`
                INSERT INTO dramas_new (id, title, description, ...)
                SELECT id, title, description, ... FROM dramas
            `).Error; err != nil {
                return err
            }
            
            // 3. 删除旧表
            if err := db.Migrator().DropTable("dramas"); err != nil {
                return err
            }
            
            // 4. 重命名新表
            if err := db.Migrator().RenameTable("dramas_new", "dramas"); err != nil {
                return err
            }
            
            return nil
        })
    },
}

// 通用表重建函数
func recreateTableWithChanges(db *gorm.DB, tableName string, modifyFn func(*gorm.DB) error) error {
    return db.Transaction(func(tx *gorm.DB) error {
        tempTable := tableName + "_temp"
        
        // 创建临时表
        if err := modifyFn(tx); err != nil {
            return err
        }
        
        // 复制索引和约束...
        
        // 原子性替换
        if err := tx.Migrator().RenameTable(tableName, tableName+"_backup"); err != nil {
            return err
        }
        if err := tx.Migrator().RenameTable(tempTable, tableName); err != nil {
            // 回滚
            tx.Migrator().RenameTable(tableName+"_backup", tableName)
            return err
        }
        
        // 删除备份（可选）
        tx.Migrator().DropTable(tableName + "_backup")
        
        return nil
    })
}
```

### 3.3 字段重命名

```go
// 场景：将Summary重命名为Description

{
    ID: "2024030101_rename_summary_to_description",
    Migrate: func(tx *gorm.DB) error {
        // MySQL/PostgreSQL
        // return tx.Migrator().RenameColumn(&models.Drama{}, "summary", "description")
        
        // SQLite：需要重建表
        return tx.Transaction(func(db *gorm.DB) error {
            // 1. 添加新列
            if err := db.Exec("ALTER TABLE dramas ADD COLUMN description text").Error; err != nil {
                return err
            }
            
            // 2. 复制数据
            if err := db.Exec("UPDATE dramas SET description = summary").Error; err != nil {
                return err
            }
            
            // 3. 删除旧列（SQLite不支持，需要重建表）
            return recreateTableWithoutColumn(db, "dramas", "summary")
        })
    },
    Rollback: func(tx *gorm.DB) error {
        // 回滚操作
        return tx.Transaction(func(db *gorm.DB) error {
            if err := db.Exec("ALTER TABLE dramas ADD COLUMN summary text").Error; err != nil {
                return err
            }
            if err := db.Exec("UPDATE dramas SET summary = description").Error; err != nil {
                return err
            }
            return recreateTableWithoutColumn(db, "dramas", "description")
        })
    },
}

// SQLite删除列函数
func recreateTableWithoutColumn(db *gorm.DB, tableName, columnToRemove string) error {
    // 获取表结构
    var columns []struct {
        Name string `gorm:"column:name"`
        Type string `gorm:"column:type"`
    }
    db.Raw(fmt.Sprintf("PRAGMA table_info(%s)", tableName)).Scan(&columns)
    
    // 构建新表结构（排除要删除的列）
    var newColumns []string
    for _, col := range columns {
        if col.Name != columnToRemove {
            newColumns = append(newColumns, col.Name)
        }
    }
    
    // 重建表...
    return nil
}
```

### 3.4 删除字段

```go
// 场景：删除废弃的OldField字段

{
    ID: "2024030501_remove_old_field",
    Migrate: func(tx *gorm.DB) error {
        // MySQL
        // return tx.Migrator().DropColumn(&models.Drama{}, "old_field")
        
        // SQLite：重建表
        return recreateTableWithoutColumn(tx, "dramas", "old_field")
    },
    Rollback: func(tx *gorm.DB) error {
        // 从备份恢复数据或重新添加列
        return tx.Exec("ALTER TABLE dramas ADD COLUMN old_field varchar(100)").Error
    },
}

// 更安全的软删除策略
{
    ID: "2024030501_deprecate_old_field",
    Migrate: func(tx *gorm.DB) error {
        // 1. 标记字段为废弃（应用层忽略）
        // 2. 可选：重命名列作为备份
        return tx.Exec("ALTER TABLE dramas RENAME COLUMN old_field TO old_field_deprecated").Error
    },
}
```

### 3.5 数据迁移

```go
// 场景：将Tags字段从逗号分隔字符串迁移到JSON数组

{
    ID: "2024031001_migrate_tags_to_json",
    Migrate: func(tx *gorm.DB) error {
        return tx.Transaction(func(db *gorm.DB) error {
            // 1. 添加临时JSON列
            if err := db.Exec("ALTER TABLE dramas ADD COLUMN tags_new JSON").Error; err != nil {
                return err
            }
            
            // 2. 查询并转换数据
            var dramas []struct {
                ID   uint
                Tags string
            }
            if err := db.Raw("SELECT id, tags FROM dramas WHERE tags IS NOT NULL").Scan(&dramas).Error; err != nil {
                return err
            }
            
            // 3. 逐条转换更新
            for _, d := range dramas {
                // 分割逗号分隔的标签
                tagList := strings.Split(d.Tags, ",")
                for i := range tagList {
                    tagList[i] = strings.TrimSpace(tagList[i])
                }
                
                // 转为JSON
                jsonTags, _ := json.Marshal(tagList)
                
                // 更新
                if err := db.Exec("UPDATE dramas SET tags_new = ? WHERE id = ?", 
                    string(jsonTags), d.ID).Error; err != nil {
                    return err
                }
            }
            
            // 4. 删除旧列，重命名新列
            // ... 重建表操作
            
            return nil
        })
    },
}
```

## 4. 索引管理

### 4.1 性能优化索引识别

```sql
-- 识别慢查询
-- 开启慢查询日志后分析

-- 1. 全表扫描检测
EXPLAIN QUERY PLAN 
SELECT * FROM dramas WHERE status = 'draft';
-- 如果看到 SCAN TABLE，需要添加索引

-- 2. 高频查询识别
-- 查看应用日志中频繁出现的查询
-- - Drama列表查询：需要status、updated_at索引
-- - Storyboard查询：需要episode_id索引

-- 3. 索引使用统计（PostgreSQL）
SELECT schemaname, tablename, indexname, idx_scan 
FROM pg_stat_user_indexes 
WHERE idx_scan = 0;
-- 长期未使用的索引可以考虑删除
```

### 4.2 唯一索引创建

```go
// 方式1：Model标签
Drama struct {
    Title string `gorm:"type:varchar(200);uniqueIndex:idx_drama_title"`
}

// 方式2：复合唯一索引
Episode struct {
    DramaID      uint `gorm:"uniqueIndex:idx_drama_episode"`
    EpisodeNum   int  `gorm:"uniqueIndex:idx_drama_episode"`
    // drama_id + episode_number 联合唯一
}

// 方式3：手动迁移创建
{
    ID: "2024031501_add_unique_index",
    Migrate: func(tx *gorm.DB) error {
        return tx.Exec(`
            CREATE UNIQUE INDEX idx_unique_drama_title 
            ON dramas(title) 
            WHERE deleted_at IS NULL
        `).Error
    },
}

// 处理重复数据后再创建唯一索引
{
    ID: "2024031502_make_title_unique",
    Migrate: func(tx *gorm.DB) error {
        // 1. 查找并处理重复项
        var duplicates []struct {
            Title string
            Count int
        }
        tx.Raw(`
            SELECT title, COUNT(*) as count 
            FROM dramas 
            GROUP BY title 
            HAVING count > 1
        `).Scan(&duplicates)
        
        // 2. 处理重复（添加编号后缀）
        for _, dup := range duplicates {
            var dramas []models.Drama
            tx.Where("title = ?", dup.Title).Find(&dramas)
            for i, d := range dramas[1:] {  // 保留第一个
                newTitle := fmt.Sprintf("%s (%d)", d.Title, i+1)
                tx.Model(&d).Update("title", newTitle)
            }
        }
        
        // 3. 创建唯一索引
        return tx.Exec("CREATE UNIQUE INDEX idx_drama_title ON dramas(title)").Error
    },
}
```

### 4.3 复合索引

```go
// 复合索引设计原则：
// 1. 等值查询字段放前面
// 2. 范围查询字段放后面
// 3. 选择性高的字段放前面

// 示例1：短剧列表查询
// 查询：WHERE status = 'draft' AND updated_at > '2024-01-01' ORDER BY updated_at DESC
Drama struct {
    Status    string    `gorm:"index:idx_status_updated,priority:1"`
    UpdatedAt time.Time `gorm:"index:idx_status_updated,priority:2"`
}

// 示例2：分镜查询
// 查询：WHERE episode_id = ? AND storyboard_number BETWEEN ? AND ?
Storyboard struct {
    EpisodeID        uint `gorm:"index:idx_episode_number,priority:1"`
    StoryboardNumber int  `gorm:"index:idx_episode_number,priority:2"`
}

// 示例3：覆盖索引（Covering Index）
// 查询只需要索引中的字段，无需回表
{
    ID: "2024032001_add_covering_index",
    Migrate: func(tx *gorm.DB) error {
        // 包含所有需要查询的字段
        return tx.Exec(`
            CREATE INDEX idx_drama_list 
            ON dramas(status, updated_at, id, title, thumbnail)
        `).Error
    },
}
```

### 4.4 索引命名规范

```go
// 命名格式：idx_{表名}_{字段名}_{字段名}

// 单字段索引
// idx_dramas_status
// idx_episodes_drama_id

// 复合索引
// idx_storyboards_episode_number
// idx_dramas_status_updated_at

// 唯一索引
// uniq_dramas_title
// uniq_episodes_drama_id_number

// Model中指定索引名
Tag struct {
    Name string `gorm:"uniqueIndex:uniq_tags_name"`
}

// 手动创建时遵循命名规范
{
    ID: "2024032501_add_performance_index",
    Migrate: func(tx *gorm.DB) error {
        return tx.Exec(`
            CREATE INDEX idx_storyboards_episode_number_status 
            ON storyboards(episode_id, storyboard_number, status)
        `).Error
    },
}
```

### 4.5 索引删除

```go
// 识别并删除无用索引
{
    ID: "2024040101_remove_unused_index",
    Migrate: func(tx *gorm.DB) error {
        // 删除索引
        return tx.Migrator().DropIndex(&models.Drama{}, "idx_old_unused")
    },
    Rollback: func(tx *gorm.DB) error {
        // 回滚时重建索引
        return tx.Exec("CREATE INDEX idx_old_unused ON dramas(old_column)").Error
    },
}

// 批量清理索引
func cleanupUnusedIndexes(db *gorm.DB) error {
    unusedIndexes := []string{
        "idx_dramas_deprecated1",
        "idx_episodes_old",
    }
    
    for _, idx := range unusedIndexes {
        if err := db.Exec(fmt.Sprintf("DROP INDEX IF EXISTS %s", idx)).Error; err != nil {
            return err
        }
    }
    return nil
}
```

## 5. 生产环境迁移

### 5.1 零停机迁移策略

```go
// 策略：影子表 + 双写 + 切换

// 阶段1：创建影子表
{
    ID: "2024040501_create_shadow_table",
    Migrate: func(tx *gorm.DB) error {
        // 创建新结构表
        return tx.Exec(`
            CREATE TABLE dramas_v2 (
                -- 新表结构
            )
        `).Error
    },
}

// 阶段2：双写（应用层修改）
// 在DramaService中同时写入新旧表
func (s *DramaService) CreateDrama(req *CreateDramaRequest) (*models.Drama, error) {
    // 写入新表
    drama := &models.Drama{...}
    if err := s.db.Create(drama).Error; err != nil {
        return nil, err
    }
    
    // 同步写入影子表（异步或同步）
    go func() {
        s.db.Table("dramas_v2").Create(drama)
    }()
    
    return drama, nil
}

// 阶段3：数据同步
{
    ID: "2024040502_sync_data",
    Migrate: func(tx *gorm.DB) error {
        // 批量同步历史数据
        return tx.Exec(`
            INSERT INTO dramas_v2 (id, title, ...)
            SELECT id, title, ... FROM dramas
            WHERE id NOT IN (SELECT id FROM dramas_v2)
        `).Error
    },
}

// 阶段4：切换读操作
// 修改应用配置，读操作切换到新表

// 阶段5：停写旧表，清理
{
    ID: "2024040503_switch_table",
    Migrate: func(tx *gorm.DB) error {
        // 重命名表
        tx.Migrator().RenameTable("dramas", "dramas_backup")
        tx.Migrator().RenameTable("dramas_v2", "dramas")
        return nil
    },
}
```

### 5.2 蓝绿部署

```yaml
# 数据库迁移与蓝绿部署配合

# 1. 蓝环境（当前运行）
#    - 使用旧表结构
#    - 正常提供服务

# 2. 执行迁移（向前兼容）
#    - 只添加新列（nullable）
#    - 添加新索引
#    - 不删除旧列

# 3. 绿环境（新版本）
#    - 使用新代码
#    - 读写新列
#    - 旧列保留但不再使用

# 4. 流量切换
#    - 切换到绿环境
#    - 观察监控指标

# 5. 验证稳定后
#    - 执行清理迁移（删除旧列）
```

### 5.3 数据备份

```go
// 迁移前自动备份
type BackupService struct {
    db *gorm.DB
}

func (s *BackupService) BackupBeforeMigration(migrationID string) error {
    backupTime := time.Now().Format("20060102_150405")
    
    // 1. 导出整个数据库
    backupPath := fmt.Sprintf("backups/pre_%s_%s.db", migrationID, backupTime)
    
    // SQLite直接复制文件
    if err := copyFile("data/drama.db", backupPath); err != nil {
        return err
    }
    
    // 2. 记录备份信息
    backup := &MigrationBackup{
        MigrationID: migrationID,
        BackupPath:  backupPath,
        CreatedAt:   time.Now(),
    }
    
    return s.db.Create(backup).Error
}

func copyFile(src, dst string) error {
    source, err := os.Open(src)
    if err != nil {
        return err
    }
    defer source.Close()
    
    destination, err := os.Create(dst)
    if err != nil {
        return err
    }
    defer destination.Close()
    
    _, err = io.Copy(destination, source)
    return err
}

// 在迁移命令中集成备份
func main() {
    flag.Parse()
    
    db, _ := initDB()
    backupSvc := &BackupService{db: db}
    
    if action == "up" {
        // 迁移前备份
        if err := backupSvc.BackupBeforeMigration("20240410_migration"); err != nil {
            log.Fatal("Backup failed:", err)
        }
    }
    
    // 执行迁移...
}
```

### 5.4 回滚计划

```go
// 每个迁移都有对应的回滚方案

// 迁移配置
var migrations = []Migration{
    {
        ID:          "2024041001_add_feature",
        Description: "添加新功能表",
        Migrate:     addFeatureTable,
        Rollback:    removeFeatureTable,
        // 回滚策略说明
        RollbackPlan: "直接删除表，数据不可恢复，建议先备份",
    },
    {
        ID:          "2024041002_modify_column",
        Description: "修改列类型",
        Migrate:     modifyColumn,
        Rollback:    restoreColumn,
        RollbackPlan: "从备份表恢复数据",
    },
}

// 快速回滚命令
func quickRollback(db *gorm.DB, backupPath string) error {
    log.Println("Starting rollback...")
    
    // 1. 停止应用（或切换到维护模式）
    
    // 2. 关闭数据库连接
    sqlDB, _ := db.DB()
    sqlDB.Close()
    
    // 3. 恢复备份
    if err := os.Remove("data/drama.db"); err != nil {
        log.Printf("Warning: failed to remove current db: %v", err)
    }
    
    if err := copyFile(backupPath, "data/drama.db"); err != nil {
        return fmt.Errorf("restore failed: %v", err)
    }
    
    log.Println("Rollback completed successfully")
    return nil
}
```

### 5.5 迁移验证清单

```markdown
## 生产环境迁移检查清单

### 迁移前
- [ ] 在非生产环境验证迁移脚本
- [ ] 创建数据库备份
- [ ] 检查磁盘空间充足
- [ ] 确认维护窗口时间
- [ ] 通知相关人员
- [ ] 准备回滚方案

### 迁移中
- [ ] 监控应用日志
- [ ] 监控数据库性能
- [ ] 记录迁移开始时间
- [ ] 逐步执行迁移步骤
- [ ] 验证每步执行结果
- [ ] 准备随时回滚

### 迁移后
- [ ] 验证应用启动正常
- [ ] 执行冒烟测试
- [ ] 验证核心功能正常
- [ ] 检查监控指标
- [ ] 确认无错误日志
- [ ] 记录迁移完成时间
- [ ] 更新文档

### 验证后24小时
- [ ] 监控性能指标
- [ ] 检查错误率
- [ ] 确认无数据异常
- [ ] 清理临时备份（如稳定）
```

## 6. 常见问题

### 6.1 迁移卡住（数据库锁定）

```bash
# 症状：迁移长时间无响应

# 诊断
# 1. 查看SQLite锁定状态
sqlite3 drama.db "PRAGMA lock_status;"

# 2. 检查活跃连接
lsof drama.db

# 解决方案
# 1. 停止所有应用实例
# 2. 确保无其他进程访问数据库
# 3. 重新执行迁移

# 预防措施：使用WAL模式
PRAGMA journal_mode=WAL;
```

### 6.2 列已存在错误

```go
// 错误：duplicate column name: xxx

// 原因：迁移被重复执行或模型和迁移不一致

// 解决方案1：使用IF NOT EXISTS
{
    ID: "2024041501_safe_add_column",
    Migrate: func(tx *gorm.DB) error {
        // 先检查列是否存在
        if !tx.Migrator().HasColumn(&models.Drama{}, "NewColumn") {
            return tx.Exec("ALTER TABLE dramas ADD COLUMN new_column varchar(100)").Error
        }
        return nil
    },
}

// 解决方案2：标记迁移为已执行（跳过）
func skipMigration(db *gorm.DB, migrationID string) error {
    return db.Exec("INSERT INTO migrations (id) VALUES (?)", migrationID).Error
}
```

### 6.3 外键约束失败

```go
// 错误：FOREIGN KEY constraint failed

// 原因：插入数据时关联的外键不存在

// 诊断查询
SELECT * FROM storyboards s 
LEFT JOIN episodes e ON s.episode_id = e.id 
WHERE e.id IS NULL;

// 修复数据
DELETE FROM storyboards WHERE episode_id NOT IN (SELECT id FROM episodes);

// 或添加ON DELETE CASCADE
{
    ID: "2024042001_fix_foreign_keys",
    Migrate: func(tx *gorm.DB) error {
        // 删除旧外键约束
        tx.Exec("ALTER TABLE storyboards DROP CONSTRAINT fk_storyboards_episode")
        
        // 添加新的级联删除
        return tx.Exec(`
            ALTER TABLE storyboards 
            ADD CONSTRAINT fk_storyboards_episode 
            FOREIGN KEY (episode_id) REFERENCES episodes(id) 
            ON DELETE CASCADE
        `).Error
    },
}
```

### 6.4 大数据表迁移优化

```go
// 问题：大数据表迁移导致长时间锁定

// 解决方案1：分批处理
{
    ID: "2024042501_migrate_large_table",
    Migrate: func(tx *gorm.DB) error {
        // 分批处理，避免长时间锁定
        batchSize := 1000
        offset := 0
        
        for {
            var count int64
            result := tx.Exec(`
                UPDATE dramas 
                SET new_field = old_field 
                WHERE id IN (
                    SELECT id FROM dramas 
                    WHERE new_field IS NULL 
                    LIMIT ?
                )
            `, batchSize)
            
            if result.Error != nil {
                return result.Error
            }
            
            if result.RowsAffected == 0 {
                break
            }
            
            offset += int(result.RowsAffected)
            log.Printf("Migrated %d records", offset)
            
            // 小延迟让出CPU
            time.Sleep(100 * time.Millisecond)
        }
        
        return nil
    },
}

// 解决方案2：使用临时表
{
    ID: "2024042502_optimize_large_migration",
    Migrate: func(tx *gorm.DB) error {
        return tx.Transaction(func(db *gorm.DB) error {
            // 1. 创建临时表（新结构）
            db.Exec(`
                CREATE TABLE dramas_new AS 
                SELECT *, old_field as new_field 
                FROM dramas
            `)
            
            // 2. 创建索引（离线进行，不影响生产）
            db.Exec("CREATE INDEX ... ON dramas_new(...)")
            
            // 3. 快速切换（原子操作）
            db.Exec("ALTER TABLE dramas RENAME TO dramas_old")
            db.Exec("ALTER TABLE dramas_new RENAME TO dramas")
            
            // 4. 旧表保留可回滚
            return nil
        })
    },
}
```

### 6.5 迁移命令参考

```bash
# 构建迁移工具
go build -o migrate cmd/migrate/main.go

# 查看迁移状态
./migrate -action=status

# 执行所有待执行迁移
./migrate -action=up

# 回滚最后一次迁移
./migrate -action=down

# 回滚到指定版本
./migrate -action=down-to -version=2024010101

# 强制标记迁移为已执行（跳过）
./migrate -action=force -version=2024041501

# 验证迁移结果
./migrate -action=verify
```

## 附录：完整的Model定义参考

```go
// domain/models/drama.go
package models

import (
    "time"
    "gorm.io/datatypes"
    "gorm.io/gorm"
)

type Drama struct {
    ID            uint           `gorm:"primaryKey;autoIncrement" json:"id"`
    Title         string         `gorm:"type:varchar(200);not null;index:idx_title" json:"title"`
    Description   *string        `gorm:"type:text" json:"description,omitempty"`
    Genre         *string        `gorm:"type:varchar(50);index:idx_genre" json:"genre,omitempty"`
    Style         string         `gorm:"type:varchar(50);default:'realistic';index:idx_style" json:"style"`
    TotalEpisodes int            `gorm:"default:1" json:"total_episodes"`
    TotalDuration int            `gorm:"default:0" json:"total_duration"`
    Status        string         `gorm:"type:varchar(20);default:'draft';not null;index:idx_status_updated" json:"status"`
    Thumbnail     *string        `gorm:"type:varchar(500)" json:"thumbnail,omitempty"`
    Tags          datatypes.JSON `gorm:"type:json" json:"tags,omitempty"`
    Metadata      datatypes.JSON `gorm:"type:json" json:"metadata,omitempty"`
    CreatedAt     time.Time      `gorm:"not null;autoCreateTime;index:idx_created" json:"created_at"`
    UpdatedAt     time.Time      `gorm:"not null;autoUpdateTime;index:idx_status_updated,priority:2" json:"updated_at"`
    DeletedAt     gorm.DeletedAt `gorm:"index" json:"-"`
    
    // 关联
    Episodes   []Episode   `gorm:"foreignKey:DramaID" json:"episodes,omitempty"`
    Characters []Character `gorm:"foreignKey:DramaID" json:"characters,omitempty"`
    Scenes     []Scene     `gorm:"foreignKey:DramaID" json:"scenes,omitempty"`
    Props      []Prop      `gorm:"foreignKey:DramaID" json:"props,omitempty"`
}

func (Drama) TableName() string {
    return "dramas"
}
```
